<!DOCTYPE html>
<html>
<head>
  <title>Краткое введение в мир матричной алгебры</title>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="generator" content="pandoc" />




  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">

  <base target="_blank">

  <script type="text/javascript">
    var SLIDE_CONFIG = {
      // Slide settings
      settings: {
                title: 'Краткое введение в мир матричной алгебры',
                        subtitle: 'Линейные модели…',
                useBuilds: true,
        usePrettify: true,
        enableSlideAreas: true,
        enableTouch: true,
                        favIcon: '06_intro_to_linear_algebra_files/logo.png',
              },

      // Author information
      presenters: [
            {
        name:  'Вадим Хайтов, Марина Варфоломеева, Арсений Гублер' ,
        company: '',
        gplus: '',
        twitter: '',
        www: '',
        github: ''
      },
            ]
    };
  </script>

  <script src="site_libs/header-attrs-2.27/header-attrs.js"></script>
  <link href="site_libs/ioslides-13.5.1/fonts/fonts.css" rel="stylesheet" />
  <link href="site_libs/ioslides-13.5.1/theme/css/default.css" rel="stylesheet" />
  <link href="site_libs/ioslides-13.5.1/theme/css/phone.css" rel="stylesheet" />
  <script src="site_libs/ioslides-13.5.1/js/modernizr.custom.45394.js"></script>
  <script src="site_libs/ioslides-13.5.1/js/prettify/prettify.js"></script>
  <script src="site_libs/ioslides-13.5.1/js/prettify/lang-r.js"></script>
  <script src="site_libs/ioslides-13.5.1/js/prettify/lang-yaml.js"></script>
  <script src="site_libs/ioslides-13.5.1/js/hammer.js"></script>
  <script src="site_libs/ioslides-13.5.1/js/slide-controller.js"></script>
  <script src="site_libs/ioslides-13.5.1/js/slide-deck.js"></script>

  <style type="text/css">

    b, strong {
      font-weight: bold;
    }

    em {
      font-style: italic;
    }

    summary {
      display: list-item;
    }

    details > summary > p:only-child {
      display: inline;
    }

    slides > slide {
      -webkit-transition: all 0.4s ease-in-out;
      -moz-transition: all 0.4s ease-in-out;
      -o-transition: all 0.4s ease-in-out;
      transition: all 0.4s ease-in-out;
    }

    .auto-fadein {
      -webkit-transition: opacity 0.6s ease-in;
      -webkit-transition-delay: 0.4s;
      -moz-transition: opacity 0.6s ease-in 0.4s;
      -o-transition: opacity 0.6s ease-in 0.4s;
      transition: opacity 0.6s ease-in 0.4s;
      opacity: 0;
    }
/* https://github.com/ropensci/plotly/pull/524#issuecomment-468142578 */
slide:not(.current) .plotly.html-widget{
  display: block;
}

    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
            pre > code.sourceCode { white-space: pre; position: relative; }
            pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
            pre > code.sourceCode > span:empty { height: 1.2em; }
            .sourceCode { overflow: visible; }
            code.sourceCode > span { color: inherit; text-decoration: inherit; }
            div.sourceCode { margin: 1em 0; }
            pre.sourceCode { margin: 0; }
            @media screen {
            div.sourceCode { overflow: auto; }
            }
            @media print {
            pre > code.sourceCode { white-space: pre-wrap; }
            pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
            }
            pre.numberSource code
              { counter-reset: source-line 0; }
            pre.numberSource code > span
              { position: relative; left: -4em; counter-increment: source-line; }
            pre.numberSource code > span > a:first-child::before
              { content: counter(source-line);
                position: relative; left: -1em; text-align: right; vertical-align: baseline;
                border: none; display: inline-block;
                -webkit-touch-callout: none; -webkit-user-select: none;
                -khtml-user-select: none; -moz-user-select: none;
                -ms-user-select: none; user-select: none;
                padding: 0 4px; width: 4em;
                color: #aaaaaa;
              }
            pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
            div.sourceCode
              {   }
            @media screen {
            pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
            }
            code span.al { color: #ff0000; font-weight: bold; } /* Alert */
            code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
            code span.at { color: #7d9029; } /* Attribute */
            code span.bn { color: #40a070; } /* BaseN */
            code span.bu { color: #008000; } /* BuiltIn */
            code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
            code span.ch { color: #4070a0; } /* Char */
            code span.cn { color: #880000; } /* Constant */
            code span.co { color: #60a0b0; font-style: italic; } /* Comment */
            code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
            code span.do { color: #ba2121; font-style: italic; } /* Documentation */
            code span.dt { color: #902000; } /* DataType */
            code span.dv { color: #40a070; } /* DecVal */
            code span.er { color: #ff0000; font-weight: bold; } /* Error */
            code span.ex { } /* Extension */
            code span.fl { color: #40a070; } /* Float */
            code span.fu { color: #06287e; } /* Function */
            code span.im { color: #008000; font-weight: bold; } /* Import */
            code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
            code span.kw { color: #007020; font-weight: bold; } /* Keyword */
            code span.op { color: #666666; } /* Operator */
            code span.ot { color: #007020; } /* Other */
            code span.pp { color: #bc7a00; } /* Preprocessor */
            code span.sc { color: #4070a0; } /* SpecialChar */
            code span.ss { color: #bb6688; } /* SpecialString */
            code span.st { color: #4070a0; } /* String */
            code span.va { color: #19177c; } /* Variable */
            code span.vs { color: #4070a0; } /* VerbatimString */
            code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
        
    slides > slide:not(.nobackground):before {
      font-size: 12pt;
      content: "";
      position: absolute;
      bottom: 20px;
      left: 60px;
      background: url(06_intro_to_linear_algebra_files/logo.png) no-repeat 0 50%;
      -webkit-background-size: 30px 30px;
      -moz-background-size: 30px 30px;
      -o-background-size: 30px 30px;
      background-size: 30px 30px;
      padding-left: 40px;
      height: 30px;
      line-height: 1.9;
    }
  </style>

  <link rel="stylesheet" href="assets/my_styles.css" type="text/css" />

</head>

<body style="opacity: 0">

<slides class="layout-widescreen">

  <slide class="title-slide segue nobackground">
        <aside class="gdbar"><img src="06_intro_to_linear_algebra_files/logo.png"></aside>
        <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 data-config-title><!-- populated from slide_config.json --></h1>
      <h2 data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p data-config-presenter><!-- populated from slide_config.json --></p>
          </hgroup>
  </slide>

<slide class=""><hgroup><h2>Вы сможете</h2></hgroup><article  id="вы-сможете">

<ul>
<li>Объяснить что такое матрицы и какие бывают их основные разновидности</li>
<li>Выполнить базовые операции с матрицами с использованием функций R</li>
<li>Применить в среде R методы матричной алгебры для решения простейших задач</li>
</ul>

</article></slide><slide class=""><hgroup><h2>Зачем понадобилась эта лекция?</h2></hgroup><article  id="зачем-понадобилась-эта-лекция">

<p><img src="images/Page_Zuur_with_matrix_notation.png" width="90%" style="display: block; margin: auto;" /></p>

</article></slide><slide class=""><hgroup><h2>Решите задачу</h2></hgroup><article  id="решите-задачу">

<p>В популяции некоторого организма в момент времени \(t_1\) представлено четыре возрастные группы:</p>

<table class = 'rmdtable'>
<tr class="header">
<th align="center">Возрастная группа</th>
<th align="center">Количество особей</th>
</tr>
<tr class="odd">
<td align="center">0+</td>
<td align="center">100</td>
</tr>
<tr class="even">
<td align="center">1+</td>
<td align="center">10</td>
</tr>
<tr class="odd">
<td align="center">2+</td>
<td align="center">5</td>
</tr>
<tr class="even">
<td align="center">3+</td>
<td align="center">1</td>
</tr>
</table>

</article></slide><slide class=""><hgroup><h2></h2></hgroup><article >

<p>Какова будет численность возрастных групп в момент времени \(t_2\) если известно, что</p>

<ol>
<li>каждая особь возрастом 2+ оставляет 10 потомков, а каждая особь возрастом 3+ - 20 потомков.</li>
<li>вероятность выживания особей при переходе от \(t_1\) к \(t_2\) описывается следующими величинами</li>
</ol>

<table class = 'rmdtable'>
<tr class="header">
<th align="center">Переход из младшей группы в старшую</th>
<th align="center">Вероятность выживания</th>
</tr>
<tr class="odd">
<td align="center">0+ - 1+</td>
<td align="center">0.1</td>
</tr>
<tr class="even">
<td align="center">1+ - 2+</td>
<td align="center">0.5</td>
</tr>
<tr class="odd">
<td align="center">2+ - 3+</td>
<td align="center">0.3</td>
</tr>
</table>

</article></slide><slide class=""><hgroup><h2>Простое, но нерациональное решение</h2></hgroup><article  id="простое-но-нерациональное-решение">

<table class = 'rmdtable'>
<tr class="header">
<th align="center">Возрастная группа</th>
<th align="center">Количество особей в момент времени \(t_2\)</th>
</tr>
<tr class="odd">
<td align="center">0+</td>
<td align="center">\(5 \cdot 10 + 1 \cdot 20 = 70\)</td>
</tr>
<tr class="even">
<td align="center">1+</td>
<td align="center">\(100 \cdot 0.1 = 10\)</td>
</tr>
<tr class="odd">
<td align="center">2+</td>
<td align="center">\(10 \cdot 0.5 = 5\)</td>
</tr>
<tr class="even">
<td align="center">3+</td>
<td align="center">\(5 \cdot 0.3 = 1.5\)</td>
</tr>
</table>

</article></slide><slide class=""><hgroup><h2>Рациональное решение</h2></hgroup><article  id="рациональное-решение">

<p>Демографический вектор в момент времени \(t_1\)</p>

<pre class = 'prettyprint lang-r'>t1 &lt;- c(100, 10, 5, 1)
t1</pre>

<pre >## [1] 100  10   5   1</pre>

</article></slide><slide class=""><hgroup><h2>Рациональное решение</h2></hgroup><article  id="рациональное-решение-1">

<p>Демографическая матрица Лесли</p>

<p>\[
\begin{pmatrix}
F_1 &amp; F_2 &amp; F_3 &amp; F_4 \\
P_{0+ -1+}&amp; 0 &amp; 0 &amp; 0  \\
0 &amp; P_{1+-2+} &amp; 0 &amp; 0  \\
0 &amp; 0 &amp; P_{2+-3+} &amp; 0  \\
\end{pmatrix}
\]</p>

<pre class = 'prettyprint lang-r'>lesley &lt;- matrix(c(c(0, 0, 10, 20), c(0.1, 0, 0, 0), c(0, 0.5, 0, 0), c(0, 0, 0.3, 0)), nrow = 4, byrow = T)

lesley</pre>

<pre >##      [,1] [,2] [,3] [,4]
## [1,]  0.0  0.0 10.0   20
## [2,]  0.1  0.0  0.0    0
## [3,]  0.0  0.5  0.0    0
## [4,]  0.0  0.0  0.3    0</pre>

</article></slide><slide class=""><hgroup><h2>Рациональное решение - решение средствами матричной алгебры</h2></hgroup><article  id="рациональное-решение---решение-средствами-матричной-алгебры">

<pre class = 'prettyprint lang-r'>lesley %*% t1</pre>

<pre >##      [,1]
## [1,] 70.0
## [2,] 10.0
## [3,]  5.0
## [4,]  1.5</pre>

</article></slide><slide class="segue dark nobackground level1"><hgroup class = 'auto-fadein'><h2>Зачем нужны матрицы?</h2></hgroup><article  id="зачем-нужны-матрицы">

</article></slide><slide class=""><hgroup><h2>Матричные объекты</h2></hgroup><article  id="матричные-объекты">

<ul>
<li>Есть много типов объектов, для которых такое выражение оказывается наиболее естественным (изображения, описания многомерных объектов и т.д.)</li>
<li>В матрицах, как и в обычных числах, скрыта информация, которую можно извлекать и преобразовывать по определенным правилам</li>
</ul>

</article></slide><slide class=""><hgroup><h2>Структура матриц</h2></hgroup><article  id="структура-матриц">

<p>\[\begin{pmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1c} \\
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2c} \\    
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
a_{r1} &amp; a_{r2} &amp; \cdots &amp; a_{rc}
\end{pmatrix}
    \]</p>

<p>Размер (порядок) матрицы \(r \times c\)</p>

</article></slide><slide class=""><hgroup><h2>Разновидности матриц</h2></hgroup><article  id="разновидности-матриц">

<p>Вектор-строка (row matrix)</p>

<p>\[ 
\textbf {A} =
\begin{pmatrix}
1 &amp; 2 &amp; 3 
\end{pmatrix}
\]</p>

<p>Вектор-столбец (column matrix)</p>

<p>\[ 
\textbf {B} =
\begin{pmatrix}
1 \\
4 \\    
7 \\
10 
\end{pmatrix}
\]</p>

</article></slide><slide class=""><hgroup><h2>Разновидности матриц</h2></hgroup><article  id="разновидности-матриц-1">

<p>Прямоугольные матрицы (rectangular matrices)</p>

<p>\[ 
\textbf {C} =
\begin{pmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\    
7 &amp; 8 &amp; 9 \\
10 &amp; 11 &amp; 12 
\end{pmatrix}
\]</p>

<p>\[ 
\textbf {D} =
\begin{pmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6     
\end{pmatrix}
\]</p>

<p>В таком виде обычно представляются исходные данные</p>

</article></slide><slide class=""><hgroup><h2>Квадратные матрицы (square matrices)</h2></hgroup><article  id="квадратные-матрицы-square-matrices">

<p>Это наиболее &ldquo;операбельные&rdquo; матрицы</p>

<p>\[ 
\textbf {E} =
\begin{pmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\    
7 &amp; 8 &amp; 9 
\end{pmatrix}
\]</p>

<p>Диагональные матрицы (diagonal matrix)</p>

<p>\[ 
\textbf {F} =
\begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 5 &amp; 0 &amp; 0 \\    
0 &amp; 0 &amp; 9 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}
\]</p>

<!-- ##Квадратные матрицы (square matrices) -->

<!-- Треугольные матрицы (triangular matrices) -->

<!-- $$ \textbf {H} = -->

<!-- \begin{pmatrix} -->

<!-- 1 & 2 & 3 & 4 \\ -->

<!-- 0 & 5 & 6 & 7 \\     -->

<!-- 0 & 0 & 9 & 10 \\ -->

<!-- 0 & 0 & 0 & 1 -->

<!-- \end{pmatrix} -->

<!-- $$ -->

<!-- или -->

<!-- $$  -->

<!-- \textbf {H} = -->

<!-- \begin{pmatrix} -->

<!-- 1 & 0 & 0 & 0 \\ -->

<!-- 3 & 5 & 0 & 0 \\     -->

<!-- 4 & 7 & 9 & 0 \\ -->

<!-- 5 & 8 & 10 & 11 -->

<!-- \end{pmatrix} -->

<!-- $$ -->

</article></slide><slide class=""><hgroup><h2>Квадратные матрицы (square matrices)</h2></hgroup><article  id="квадратные-матрицы-square-matrices-1">

<p>Единичная матрица (identity matrix) \[ 
\textbf {I} =
\begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\    
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}
\]</p>

<p>Единичная матрица (обозначение \(\textbf{I}\)) занимают особое место в матричной алгебре.<br/>Она выполняет ту же роль, которую выполняет единица в обычной алгебре.</p>

</article></slide><slide class=""><hgroup><h2>Особенность квадратных матриц</h2></hgroup><article  id="особенность-квадратных-матриц">

<p>Для квадратных матриц могут быть найдены (но не обязательно существуют) некоторые важные для матричной алгебры показатели: <em>определитель</em>, <em>инверсия</em>, <em>собственные значения</em> и <em>собственные векторы</em></p>

</article></slide><slide class=""><hgroup><h2>Задание</h2></hgroup><article  id="задание">

<p>Создайте с помощью R следующую матрицу</p>

<p>\[ 
\begin{pmatrix}
1 &amp; 2 &amp; 3 &amp; 4 \\
5 &amp; 6 &amp; 7 &amp; 8 \\    
9 &amp; 10 &amp; 11 &amp; 12 \\
\end{pmatrix}
\]</p>

</article></slide><slide class=""><hgroup><h2>Решение</h2></hgroup><article  id="решение">

<pre class = 'prettyprint lang-r'>matrix(1:12, ncol = 3, byrow = TRUE)</pre>

<pre >##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6
## [3,]    7    8    9
## [4,]   10   11   12</pre>

</article></slide><slide class=""><hgroup><h2>Задание</h2></hgroup><article  id="задание-1">

<p>Создайте с помощью R единичную матрицу</p>

<p>\[ 
\begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\    
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 
\end{pmatrix}
\]</p>

</article></slide><slide class=""><hgroup><h2>Решение</h2></hgroup><article  id="решение-1">

<pre class = 'prettyprint lang-r'>diag(rep(1,5))</pre>

<pre >##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    0    0    0    0
## [2,]    0    1    0    0    0
## [3,]    0    0    1    0    0
## [4,]    0    0    0    1    0
## [5,]    0    0    0    0    1</pre>

</article></slide><slide class="segue dark nobackground level1"><hgroup class = 'auto-fadein'><h2>Операции с матрицами</h2></hgroup><article  id="операции-с-матрицами">

</article></slide><slide class=""><hgroup><h2>Транспонирование матриц</h2></hgroup><article  id="транспонирование-матриц">

<pre class = 'prettyprint lang-r'>A &lt;- matrix(1:12, ncol = 3)
A</pre>

<pre >##      [,1] [,2] [,3]
## [1,]    1    5    9
## [2,]    2    6   10
## [3,]    3    7   11
## [4,]    4    8   12</pre>

<p>Транспонированная матрица \(\textbf{A}\)</p>

<pre class = 'prettyprint lang-r'>B &lt;- t(A)
B</pre>

<pre >##      [,1] [,2] [,3] [,4]
## [1,]    1    2    3    4
## [2,]    5    6    7    8
## [3,]    9   10   11   12</pre>

</article></slide><slide class=""><hgroup><h2>Сложение матриц</h2></hgroup><article  id="сложение-матриц">

<pre class = 'prettyprint lang-r'>A + 4</pre>

<pre >##      [,1] [,2] [,3]
## [1,]    5    9   13
## [2,]    6   10   14
## [3,]    7   11   15
## [4,]    8   12   16</pre>

<pre class = 'prettyprint lang-r'>A + A</pre>

<pre >##      [,1] [,2] [,3]
## [1,]    2   10   18
## [2,]    4   12   20
## [3,]    6   14   22
## [4,]    8   16   24</pre>

<p>Но! Нельзя складывать матрицы разных размеров</p>

<pre class = 'prettyprint lang-r'>A + B</pre>

<pre >## Error in A + B: non-conformable arrays</pre>

</article></slide><slide class=""><hgroup><h2>Биологическое приложение</h2></hgroup><article  id="биологическое-приложение">

<p>Предположим, что мы подсчитывали двумя разными методами крупных и мелких животных трех видов в одних и тех же пробах</p>

<pre >##         Sp1 Sp2 Sp3
## Sample1  11  11   9
## Sample2  13  12   9
## Sample3  13  11  13
## Sample4   8  16   7
## Sample5   8  12   8</pre>

<pre >##         Sp1 Sp2 Sp3
## Sample1  56  46  46
## Sample2  62  53  46
## Sample3  40  53  44
## Sample4  59  52  50
## Sample5  45  52  54</pre>

</article></slide><slide class=""><hgroup><h2>Биологическое приложение</h2></hgroup><article  id="биологическое-приложение-1">

<p>Общее обилие</p>

<pre class = 'prettyprint lang-r'>Large + Small</pre>

<pre >##         Sp1 Sp2 Sp3
## Sample1  67  57  55
## Sample2  75  65  55
## Sample3  53  64  57
## Sample4  67  68  57
## Sample5  53  64  62</pre>

</article></slide><slide class=""><hgroup><h2>Простое умножение</h2></hgroup><article  id="простое-умножение">

<p>Умножение на число</p>

<pre class = 'prettyprint lang-r'>A * 4</pre>

<pre >##      [,1] [,2] [,3]
## [1,]    4   20   36
## [2,]    8   24   40
## [3,]   12   28   44
## [4,]   16   32   48</pre>

<p>Простое умножение матрицы на вектор возможно только если число элементов в векторе равно числу строк в матрице</p>

<pre class = 'prettyprint lang-r'>A * c(10, 11, 12, 13)</pre>

<pre >##      [,1] [,2] [,3]
## [1,]   10   50   90
## [2,]   22   66  110
## [3,]   36   84  132
## [4,]   52  104  156</pre>

<p>Все элементы первой строки матрицы умножаются на первый элемент вектора, все элементы второй строки на второй элемент вектора и т.д.</p>

</article></slide><slide class=""><hgroup><h2>Биологическое применение</h2></hgroup><article  id="биологическое-применение">

<p>Допустим, учет организмов в части описаний проходил не на всей выборке, а лишь в ее части.</p>

<pre class = 'prettyprint lang-r'>Rpocessed_portion &lt;- c(1, 1, 1/2, 1/3, 1/4)
Processed_Factor &lt;- 1/Rpocessed_portion</pre>

<pre class = 'prettyprint lang-r'>Small * Processed_Factor</pre>

<pre >##         Sp1 Sp2 Sp3
## Sample1  56  46  46
## Sample2  62  53  46
## Sample3  80 106  88
## Sample4 177 156 150
## Sample5 180 208 216</pre>

</article></slide><slide class=""><hgroup><h2>Скалярное произведение векторов</h2></hgroup><article  id="скалярное-произведение-векторов">

<p>Допустимо только для векторов одинаковой размерности</p>

<p>\[
\textbf{a} \bullet \textbf{b} =  
\begin{pmatrix}
a_1 \\ a_2 \\ a_3 \\ a_4 \\ a_5 \\ a_6 \\ a_7
\end{pmatrix}
\times
\begin{pmatrix}
b_1 &amp; b_2 &amp; b_3 &amp; b_4 &amp; b_5 &amp; b_6 &amp; b_7
\end{pmatrix}
= a_1 \cdot b_1 + a_2 \cdot b_2 + \ldots + a_7 \cdot b_7 = x 
\]</p>

<p>Результат этой операции - число (скаляр)</p>

</article></slide><slide class=""><hgroup><h2>Биологическое применение</h2></hgroup><article  id="биологическое-применение-1">

<p>Сколько особей родится в популяции, если мы знаем репродуктивные характеристики всех возрастных групп? \[
\begin{pmatrix}
N_1 \\ N_2 \\ N_3 \\ N_4 \\ N_5 \\ N_6 \\ N_7
\end{pmatrix}
\times
\begin{pmatrix}
F_1 &amp; F_2 &amp; F_3 &amp; F_4 &amp; F_5 &amp; F_6 &amp; F_7
\end{pmatrix}
\]</p>

<pre class = 'prettyprint lang-r'>N &lt;- c(20, 40, 32, 45, 80, 50, 10)
Fert &lt;- c( 0,  0,   1,   2,   2,   0,   0)
t(N) %*% (Fert)</pre>

<pre >##      [,1]
## [1,]  282</pre>

</article></slide><slide class=""><hgroup><h2>Умножение матриц</h2></hgroup><article  id="умножение-матриц" class="smaller">

<p>Умножать можно только в том случае, если число строк одной из матриц равно числу столбцов у другой матрицы.</p>

<pre class = 'prettyprint lang-r'>A</pre>

<pre >##      [,1] [,2] [,3]
## [1,]    1    5    9
## [2,]    2    6   10
## [3,]    3    7   11
## [4,]    4    8   12</pre>

<pre class = 'prettyprint lang-r'>B</pre>

<pre >##      [,1] [,2] [,3] [,4]
## [1,]    1    2    3    4
## [2,]    5    6    7    8
## [3,]    9   10   11   12</pre>

<pre class = 'prettyprint lang-r'>A %*% B</pre>

<pre >##      [,1] [,2] [,3] [,4]
## [1,]  107  122  137  152
## [2,]  122  140  158  176
## [3,]  137  158  179  200
## [4,]  152  176  200  224</pre>

<p>У первой матрицы (<code>A</code>) число строк равно числу столбцов у второй матрицы (<code>B</code>)</p>

</article></slide><slide class=""><hgroup><h2>Умножение матриц</h2></hgroup><article  id="умножение-матриц-1">

<p>Порядок имеет смысл! Если поменять местами матрицы <code>A</code> и <code>B</code>, то изменится и результат</p>

<pre class = 'prettyprint lang-r'>B %*% A</pre>

<pre >##      [,1] [,2] [,3]
## [1,]   30   70  110
## [2,]   70  174  278
## [3,]  110  278  446</pre>

</article></slide><slide class=""><hgroup><h2>Умножение матриц</h2></hgroup><article  id="умножение-матриц-2">

<p>Удалим из матрицы <code>B</code> последнюю строчку</p>

<pre class = 'prettyprint lang-r'>C &lt;- B[-3, ]
C</pre>

<pre >##      [,1] [,2] [,3] [,4]
## [1,]    1    2    3    4
## [2,]    5    6    7    8</pre>

<p>Такое произведение возможно</p>

<pre class = 'prettyprint lang-r'>C %*% A</pre>

<pre >##      [,1] [,2] [,3]
## [1,]   30   70  110
## [2,]   70  174  278</pre>

<p>Но невозможно такое произведение</p>

<pre class = 'prettyprint lang-r'>A %*% C</pre>

<pre >## Error in A %*% C: non-conformable arguments</pre>

</article></slide><slide class=""><hgroup><h2>Умножение матриц</h2></hgroup><article  id="умножение-матриц-3">

<p>Если матрица (&lsquo;A&rsquo;) не квадратная, то нельзя произвести такое умножение</p>

<pre class = 'prettyprint lang-r'>A %*% A</pre>

</article></slide><slide class=""><hgroup><h2>Схема умножения матриц</h2></hgroup><article  id="схема-умножения-матриц">

<pre class = 'prettyprint lang-r'>M1 &lt;- matrix(c(1, 2, 3, 4, 5, 6), byrow = T, ncol = 3)
M2 &lt;-  matrix(7:12, byrow = T, ncol = 2)
M1 %*% M2  </pre>

<pre >##      [,1] [,2]
## [1,]   58   64
## [2,]  139  154</pre>

<p>\[
\begin{pmatrix}
1 &amp; 2 &amp; 3 \\ 
4 &amp; 5 &amp; 6 \\
\end{pmatrix}
\times
\begin{pmatrix}
7 &amp; 8 \\ 9 &amp; 10\\ 11 &amp; 12\\
\end{pmatrix}
=
\begin{pmatrix}
7 \cdot 1 + 9 \cdot 2 + 11 \cdot 3 &amp; 8 \cdot 1 + 10 \cdot 2 + 12 \cdot 3 \\ 7 \cdot 4 + 9 \cdot 5 + 11 \cdot 6 &amp; 8 \cdot 4 + 10 \cdot 5 + 12 \cdot 6  \\
\end{pmatrix}
= \\
=
\begin{pmatrix}
58 &amp; 64 \\ 139 &amp; 154\\ 
\end{pmatrix}
\]</p>

</article></slide><slide class=""><hgroup><h2>Схема умножения матриц</h2></hgroup><article  id="схема-умножения-матриц-1">

<p>\[
\begin{pmatrix}
A &amp; B  \\
C &amp; D \\
\end{pmatrix}
\times
\begin{pmatrix}
E &amp; F \\ G &amp; H\\ 
\end{pmatrix}
=
\begin{pmatrix}
(A \cdot E + B \cdot G)  &amp; (A \cdot F + B \cdot H ) \\ (C \cdot E + D \cdot G)  &amp; (C \cdot F + D \cdot H)  \\
\end{pmatrix}
\]</p>

</article></slide><slide class=""><hgroup><h2>Биологическое применение</h2></hgroup><article  id="биологическое-применение-2">

<p>Простейший пример использования умножения матриц - построение модели динамики демографической структуры популяции Для вычислений необходим начальный <em>демографический вектор</em> и <em>матрица Лесли</em></p>

<p>\[
\begin{pmatrix}
F_1 &amp; F_2 &amp; F_3 &amp; F_4 &amp; F_5 &amp; F_6 &amp; F_7 \\
P_{1-2}&amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\    
0 &amp; P_{2-3} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\    
0 &amp; 0 &amp; P_{3-4} &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\    
0 &amp; 0 &amp; 0 &amp; P_{4-5} &amp; 0 &amp; 0 &amp; 0 \\    
0 &amp; 0 &amp; 0 &amp; 0 &amp; P_{5-6} &amp; 0 &amp; 0 \\    
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; P_{6-7} &amp; 0     
\end{pmatrix}
\times
\begin{pmatrix}
N1_t \\
N2_t \\
N3_t \\    
N4_t \\
N5_t \\
N6_t \\
N7_t
\end{pmatrix}
=
\begin{pmatrix}
N1_{t+1} \\
N2_{t+1} \\
N3_{t+1} \\    
N4_{t+1} \\
N5_{t+1} \\
N6_{t+1} \\
N7_{t+1}
\end{pmatrix}
\]</p>

</article></slide><slide class=""><hgroup><h2>Простейшая демографическая модель</h2></hgroup><article  id="простейшая-демографическая-модель">

<p>Демографический вектор в момент времени \(t\)</p>

<pre >##     Age T1
## 1     0 20
## 2  1-10 40
## 3 11-20 32
## 4 21-35 45
## 5 36-45 80
## 6 46-55 50
## 7 56-65 10</pre>

<p>Матрица Лесли</p>

<pre >##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
## [1,]  0.0  0.0  1.0  2.0  2.0  0.0    0
## [2,]  0.6  0.0  0.0  0.0  0.0  0.0    0
## [3,]  0.0  0.7  0.0  0.0  0.0  0.0    0
## [4,]  0.0  0.0  0.8  0.0  0.0  0.0    0
## [5,]  0.0  0.0  0.0  0.7  0.0  0.0    0
## [6,]  0.0  0.0  0.0  0.0  0.6  0.0    0
## [7,]  0.0  0.0  0.0  0.0  0.0  0.2    0</pre>

</article></slide><slide class=""><hgroup><h2>Демографическая струкутра в момент времени \(t+1\)</h2></hgroup><article  id="демографическая-струкутра-в-момент-времени-t1">

<pre class = 'prettyprint lang-r'>Pop$T2 &lt;- as.vector( Lesl %*% (Pop$T1 ))
Pop$T3 &lt;- as.vector( Lesl %*% (Pop$T2 ))
Pop$T4 &lt;- as.vector( Lesl %*% (Pop$T3 ))
Pop$T5 &lt;- as.vector( Lesl %*% (Pop$T4 ))
Pop$T6 &lt;- as.vector( Lesl %*% (Pop$T5 ))
Pop$T7 &lt;- as.vector( Lesl %*% (Pop$T6 ))
Pop$T8 &lt;- as.vector( Lesl %*% (Pop$T7 ))
Pop$T9 &lt;- as.vector( Lesl %*% (Pop$T8 ))
Pop$T10 &lt;- as.vector( Lesl %*% (Pop$T9 ))</pre>

</article></slide><slide class=""><hgroup><h2>Демографическая струкутра в момент времени \(t+1\)</h2></hgroup><article  id="демографическая-струкутра-в-момент-времени-t1-1">

<p><img src="06_intro_to_linear_algebra_files/figure-html/unnamed-chunk-32-1.png" width="576" style="display: block; margin: auto;" /></p>

</article></slide><slide class=""><hgroup><h2>Задание</h2></hgroup><article  id="задание-2">

<p>Представим себе, что вы решили купить четыре товара, по следующим ценам</p>

<p>\[
\begin{matrix}
Товар &amp; Цена \\
\hline
Товар 1 &amp; 10 \\
Товар 2 &amp; 20 \\
Товар 3 &amp; 30 \\
Товар 4 &amp; 40 \\
\end{matrix}
\]</p>

<p>Прямых выходов на продавца у вас нет, но есть три посредника, которые выставляют следующие &ldquo;накрутки&rdquo; цен.</p>

<p>Какой из посредников выгоднее?</p>

<p>\[
\begin{matrix}
 &amp; Товар 1 &amp; Товар 2 &amp; Товар 3 &amp; Товар 4 \\
\hline
Посредник 1 &amp; 0.1&amp; 0.15&amp; 0.05&amp; 0.05 \\
Посредник 2 &amp; 0.15&amp; 0.15&amp; 0.09&amp; 0.01 \\
Посредник 3 &amp; 0.2&amp; 0.05&amp; 0.1&amp; 0.1  
\end{matrix}
\]</p>

</article></slide><slide class=""><hgroup><h2>Вычисление корреляций через произведение матриц</h2></hgroup><article  id="вычисление-корреляций-через-произведение-матриц">

<p>\[\bf{Cor} = \frac{\bf{{X}&#39;_{stand}}\bf{X_{stand}}}{N-1}\]</p>

<p>Используем известные нам данные по размеру головного мозга</p>

<pre class = 'prettyprint lang-r'>brain &lt;- read.csv(&quot;data/IQ_brain.csv&quot;, header = TRUE)
br &lt;- brain[complete.cases(brain), -1]
br &lt;- as.matrix(br)
br_scaled &lt;- scale(br) #Стандартизуем значения

t(br_scaled) %*% br_scaled / (nrow(br_scaled) - 1) </pre>

<pre >##               FSIQ     VIQ      PIQ   Weight  Height MRINACount
## FSIQ        1.0000  0.9451  0.93443 -0.05148 -0.1184      0.334
## VIQ         0.9451  1.0000  0.77602 -0.07609 -0.1190      0.300
## PIQ         0.9344  0.7760  1.00000  0.00251 -0.0932      0.378
## Weight     -0.0515 -0.0761  0.00251  1.00000  0.6996      0.513
## Height     -0.1184 -0.1190 -0.09316  0.69961  1.0000      0.588
## MRINACount  0.3337  0.3003  0.37778  0.51338  0.5884      1.000</pre>

</article></slide><slide class=""><hgroup><h2>Задание</h2></hgroup><article  id="задание-3">

<p>Используя датасет <code>iris</code>, вычислите корреляцию между <code>Sepal.Length</code> и <code>Sepal.Width</code></p>

</article></slide><slide class=""><hgroup><h2>Решение</h2></hgroup><article  id="решение-2" class="smaller">

<pre class = 'prettyprint lang-r'>L &lt;- iris$Sepal.Length
W &lt;- iris$Sepal.Width
matr &lt;- as.matrix(data.frame(L, W), ncol = 2)

matr_scaled &lt;- scale(matr)

t(matr_scaled) %*% matr_scaled / (nrow(matr_scaled) - 1) </pre>

<pre >##        L      W
## L  1.000 -0.118
## W -0.118  1.000</pre>

<p>Проверим</p>

<pre class = 'prettyprint lang-r'>cor(matr)</pre>

<pre >##        L      W
## L  1.000 -0.118
## W -0.118  1.000</pre>

</article></slide><slide class="segue dark nobackground level1"><hgroup class = 'auto-fadein'><h2>Важные положения теории матриц</h2></hgroup><article  id="важные-положения-теории-матриц">

</article></slide><slide class=""><hgroup><h2>Если существует произведение матриц \(\textbf{BC}\), то не обязательно существует \(\textbf{CB}\)</h2></hgroup><article  id="если-существует-произведение-матриц-textbfbc-то-не-обязательно-существует-textbfcb">

<pre class = 'prettyprint lang-r'>B &lt;- matrix(1:24, ncol = 4)
C &lt;- matrix(1:12, ncol = 3)

B %*% C</pre>

<pre >##      [,1] [,2] [,3]
## [1,]  130  290  450
## [2,]  140  316  492
## [3,]  150  342  534
## [4,]  160  368  576
## [5,]  170  394  618
## [6,]  180  420  660</pre>

<p>HO!</p>

<pre class = 'prettyprint lang-r'>C %*% B</pre>

<pre >## Error in C %*% B: non-conformable arguments</pre>

<p>Такое произведение невозможно</p>

</article></slide><slide class=""><hgroup><h2>Всегда существует такое произведение матриц \(\textbf{CС&#39;}\) и \(\textbf{C&#39;С}\)</h2></hgroup><article  id="всегда-существует-такое-произведение-матриц-textbfcс-и-textbfcс">

<pre class = 'prettyprint lang-r'>C %*% t(C)</pre>

<pre >##      [,1] [,2] [,3] [,4]
## [1,]  107  122  137  152
## [2,]  122  140  158  176
## [3,]  137  158  179  200
## [4,]  152  176  200  224</pre>

<pre class = 'prettyprint lang-r'>t(C) %*% C</pre>

<pre >##      [,1] [,2] [,3]
## [1,]   30   70  110
## [2,]   70  174  278
## [3,]  110  278  446</pre>

</article></slide><slide class=""><hgroup><h2>Произведение матриц \(\textbf{BC}\) как правило не равно \(\textbf{CB}\)</h2></hgroup><article  id="произведение-матриц-textbfbc-как-правило-не-равно-textbfcb">

<pre class = 'prettyprint lang-r'>B &lt;- matrix(1:9, ncol = 3)
C &lt;- matrix(11:19, ncol = 3)

B %*%  C</pre>

<pre >##      [,1] [,2] [,3]
## [1,]  150  186  222
## [2,]  186  231  276
## [3,]  222  276  330</pre>

<pre class = 'prettyprint lang-r'>C %*% B</pre>

<pre >##      [,1] [,2] [,3]
## [1,]   90  216  342
## [2,]   96  231  366
## [3,]  102  246  390</pre>

</article></slide><slide class=""><hgroup><h2>\([\textbf{BC}]&#39; = \textbf{C}&#39;\textbf{B}&#39;\)</h2></hgroup><article  id="textbfbc-textbfctextbfb">

<pre class = 'prettyprint lang-r'>t(B %*% C)</pre>

<pre >##      [,1] [,2] [,3]
## [1,]  150  186  222
## [2,]  186  231  276
## [3,]  222  276  330</pre>

<pre class = 'prettyprint lang-r'>t(C) %*% t(B)</pre>

<pre >##      [,1] [,2] [,3]
## [1,]  150  186  222
## [2,]  186  231  276
## [3,]  222  276  330</pre>

</article></slide><slide class=""><hgroup><h2>Произведение \(\textbf{BB&#39;}\) и \(\textbf{B&#39;B}\) всегда дает симметричную матрицу</h2></hgroup><article  id="произведение-textbfbb-и-textbfbb-всегда-дает-симметричную-матрицу">

<pre class = 'prettyprint lang-r'>B %*% t(B)</pre>

<pre >##      [,1] [,2] [,3]
## [1,]   66   78   90
## [2,]   78   93  108
## [3,]   90  108  126</pre>

<pre class = 'prettyprint lang-r'>t(B) %*% B</pre>

<pre >##      [,1] [,2] [,3]
## [1,]   14   32   50
## [2,]   32   77  122
## [3,]   50  122  194</pre>

</article></slide><slide class=""><hgroup><h2>Определтель матрицы</h2></hgroup><article  id="определтель-матрицы">

<p>Определитель матрицы — это некоторое число.</p>

<p>По значению этого числа можно <em>определить</em> есть ли у матрицы некоторые свойства (например, обратима ли матрица).</p>

<p>Определитель бывает <em>только у квадратных матриц</em>.</p>

</article></slide><slide class=""><hgroup><h2>Определтель матрицы</h2></hgroup><article  id="определтель-матрицы-1" class="columns-2 smaller">

<p>Матрицы, имеющие определитель равный нулю, называются <em>сингулярными</em> матрицами.</p>

<pre class = 'prettyprint lang-r'>B</pre>

<pre >##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9</pre>

<pre class = 'prettyprint lang-r'>det(B)</pre>

<pre >## [1] 0</pre>

<p><br> <br></p>

<p>НО!</p>

<pre class = 'prettyprint lang-r'>B[3,3] &lt;- B[3,3] + 1
B</pre>

<pre >##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6   10</pre>

<pre class = 'prettyprint lang-r'>det(B)</pre>

<pre >## [1] -3</pre>

</article></slide><slide class=""><hgroup><h2>Обращение (инверсия) матриц</h2></hgroup><article  id="обращение-инверсия-матриц">

<p>В матричной алгебре нет процедуры деления. Вместо нее используют обращение матриц.</p>

<p>\[
\textbf{X}^{-1}\textbf{X} = \textbf{I}
\]</p>

<p>Произведение инверсии матрицы и исходной матрицы дает единичную матрицу</p>

</article></slide><slide class=""><hgroup><h2>Обращение (инверсия) матриц</h2></hgroup><article  id="обращение-инверсия-матриц-1">

<p>Только некоторые квадратные матрицы, могут иметь обратную матрицу.</p>

<p>Поэтому для квадратных матриц справедливо \[\textbf{X} \textbf{X}^{-1} = \textbf{X}^{-1} \textbf{X}\]</p>

</article></slide><slide class=""><hgroup><h2>Обращение (инверсия) матриц</h2></hgroup><article  id="обращение-инверсия-матриц-2">

<p>Для матриц, определитель которых равен нулю, обратной матрицы не существует</p>

</article></slide><slide class=""><hgroup><h2>Обращение матриц в среде R</h2></hgroup><article  id="обращение-матриц-в-среде-r">

<p>Создадим матрицу</p>

<pre >##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6
## [3,]    7    8   10</pre>

<p>Ее определитель</p>

<pre class = 'prettyprint lang-r'>det(X)</pre>

<pre >## [1] -3</pre>

</article></slide><slide class=""><hgroup><h2>Обращение матриц в среде R</h2></hgroup><article  id="обращение-матриц-в-среде-r-1">

<p>Обратная матрица</p>

<pre class = 'prettyprint lang-r'>solve(X)</pre>

<pre >##        [,1]  [,2] [,3]
## [1,] -0.667 -1.33    1
## [2,] -0.667  3.67   -2
## [3,]  1.000 -2.00    1</pre>

<p>По определению, \(\textbf{X}^{-1}\textbf{X} = \textbf{I}\)</p>

<pre class = 'prettyprint lang-r'>round(solve(X) %*% X )</pre>

<pre >##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    1    0
## [3,]    0    0    1</pre>

</article></slide><slide class="segue dark nobackground level1"><hgroup class = 'auto-fadein'><h2>Примнение обращенных матриц</h2></hgroup><article  id="примнение-обращенных-матриц">

</article></slide><slide class=""><hgroup><h2>Решение систем линейных уравнений</h2></hgroup><article  id="решение-систем-линейных-уравнений">

<p>Простейший случай использования обратных матриц - решение систем линейных уравнений \[
\begin{cases}
1x + 2y + 3z = 2\\  
4x + 5y + 6z = 4 \\  
7x + 8y + 10z = 10   
\end{cases}
\]</p>

<p>Эту систему можно представить в матричном виде</p>

<p>\[
\begin{pmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
7 &amp; 8 &amp; 10
\end{pmatrix}
\begin{pmatrix}
x \\ y \\ z
\end{pmatrix}
=
\begin{pmatrix}
2 \\ 4 \\ 10
\end{pmatrix}
\]</p>

<p>Тогда</p>

<p>\[
\begin{pmatrix}
x \\ y \\ z
\end{pmatrix}
=
\begin{pmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
7 &amp; 8 &amp; 10
\end{pmatrix}
^{-1}
\begin{pmatrix}
2 \\ 4 \\ 10
\end{pmatrix}
\]</p>

</article></slide><slide class=""><hgroup><h2>Зачем нужен определитель</h2></hgroup><article  id="зачем-нужен-определитель">

<p>Если определитель матрицы коэффициентов не равен нулю, то для этой матрицы возможно обращение, а система уравнений имеет решение.</p>

<p>С помощью определителя матрицы коэффициентов можно определить будет ли система уравнений иметь решение.</p>

<p>Если определитель равен нулю, то инверсия матрицы невозможна и система уравнений имеет бесконечное количество решений.</p>

</article></slide><slide class=""><hgroup><h2>Задание</h2></hgroup><article  id="задание-4">

<p>Решите приведенную систему уравнений с использованием матричной алгебры</p>

<p>\[
\begin{cases}
1x + 2y + 3z = 2\\  
4x + 5y + 6z = 4 \\  
7x + 8y + 10z = 10   
\end{cases}
\]</p>

</article></slide><slide class=""><hgroup><h2>Решение</h2></hgroup><article  id="решение-3">

<pre class = 'prettyprint lang-r'>Coef &lt;- matrix(c(1 , 2 , 3 ,
         4 , 5 , 6 ,
         7 , 8 , 10), byrow = T, ncol = 3)
Val &lt;- c(2,4,10)

solve(Coef) %*% Val</pre>

<pre >##       [,1]
## [1,]  3.33
## [2,] -6.67
## [3,]  4.00</pre>

</article></slide><slide class=""><hgroup><h2>Проверим</h2></hgroup><article  id="проверим">

<pre class = 'prettyprint lang-r'>round(1*3.33 + 2*-6.67 + 3*4.00)</pre>

<pre >## [1] 2</pre>

<pre class = 'prettyprint lang-r'>round(4*3.33 + 5*-6.67 + 6*4.00)</pre>

<pre >## [1] 4</pre>

<pre class = 'prettyprint lang-r'>round(7*3.33 + 8*-6.67 + 10*4.00)</pre>

<pre >## [1] 10</pre>

</article></slide><slide class=""><hgroup><h2>Задание</h2></hgroup><article  id="задание-5">

<p>Решите систему из двух уравнений</p>

<p>\[
\left\{\begin{array}{c}2x-4y=-6\\ 2x+y=4\end{array}\right.
\]</p>

</article></slide><slide class="segue dark nobackground level1"><hgroup class = 'auto-fadein'><h2>Подбор параметров линейной регрессии методом наименьших квадратов с использованием матричной алгебры</h2></hgroup><article  id="подбор-параметров-линейной-регрессии-методом-наименьших-квадратов-с-использованием-матричной-алгебры">

</article></slide><slide class=""><hgroup><h2>Линейная регрессия в матричном виде</h2></hgroup><article  id="линейная-регрессия-в-матричном-виде">

<p>Модель линейной регрессии \(y_i = b_0 + b_1x_i + e_i\) можно записать в матричном виде</p>

<p>\[
\mathbf{y} = \mathbf{X}{\pmb{\beta}} + \mathbf{e}
\] Или</p>

<p>\[
\mathbf{\hat{y}} = \mathbf{X}{\pmb{\beta}} 
\]</p>

<p>Здесь</p>

<p>\(\textbf{y}\) - вектор наблюдаемых значений зависимой переменной</p>

<p>\(\mathbf{\hat{y}}\) - вектор предсказанных значений зависимой переменной</p>

<p>\(\textbf{X}\) - модельная матрица</p>

<p>\(\pmb{\beta}\) - вектор коэффициентов модели \(b_0 + b_1x\): \((b_0, b_1)\)</p>

<p>\(\mathbf{e}\) — вектор остатков.</p>

</article></slide><slide class=""><hgroup><h2>Модельная матрица</h2></hgroup><article  id="модельная-матрица">

<p>Это матрица, описывающая &ldquo;поведение&rdquo; предикторов.</p>

<p>Для модели \(y_i = b_0 + b_1x_i + e_i\)</p>

<p>\[
\mathbf{X} = 
\begin{pmatrix}
1 &amp; x_1 \\
1 &amp; x_2 \\
\vdots &amp; \vdots\\
1 &amp; x_n \\
\end{pmatrix}
\]</p>

</article></slide><slide class=""><hgroup><h2>Решение этого уравнения</h2></hgroup><article  id="решение-этого-уравнения">

<p>Умножим обе части уравнения на транспонированную матрицу \(\textbf{X}&#39;\)</p>

<p>\[ \textbf{X}&#39;  \textbf{y} = \textbf{X}&#39;\textbf{X} \pmb{\beta}\]</p>

<p>Матрица \(\textbf{X}&#39;\textbf{X}\) - это всегда квадратная матрица. Ее можно обратить.</p>

<p>Тогда \[
\pmb{\beta} = [\textbf{X}&#39;\textbf{X}]^{-1}[\textbf{X}&#39;\textbf{y}]
\]</p>

</article></slide><slide class=""><hgroup><h2>Подбираем коэффициенты с помощью фунции <code>lm()</code></h2></hgroup><article  id="подбираем-коэффициенты-с-помощью-фунции-lm">

<pre class = 'prettyprint lang-r'>brain &lt;- read.csv(&quot;data/IQ_brain.csv&quot;, header = TRUE)

M_brain &lt;- lm(PIQ ~ MRINACount, data = brain)</pre>

</article></slide><slide class=""><hgroup><h2>Коэффициенты модели</h2></hgroup><article  id="коэффициенты-модели">

<pre class = 'prettyprint lang-r'>coefficients(M_brain)</pre>

<pre >## (Intercept)  MRINACount 
##     1.74376     0.00012</pre>

</article></slide><slide class=""><hgroup><h2>Графическое отражение, построенное с помощью <code>geom_smooth()</code></h2></hgroup><article  id="графическое-отражение-построенное-с-помощью-geom_smooth">

<pre class = 'prettyprint lang-r'>library(ggplot2)
theme_set(theme_bw())
ggplot(brain, aes(x = MRINACount, y = PIQ)) + geom_point() + geom_smooth(method = &quot;lm&quot;)</pre>

<pre >## `geom_smooth()` using formula = &#39;y ~ x&#39;</pre>

<p><img src="06_intro_to_linear_algebra_files/figure-html/unnamed-chunk-55-1.png" width="672" style="display: block; margin: auto;" /></p>

<center>

<strong>Мы научимся все эти результаты получать вручную!</strong>

</center>

</article></slide><slide class=""><hgroup><h2>Вычисление коэффициентов линейной регрессии вручную</h2></hgroup><article  id="вычисление-коэффициентов-линейной-регрессии-вручную">

<p>Находим вектор коэффициентов на основе уравнения \[\pmb{\beta} = [\textbf{X}&#39;\textbf{X}]^{-1}[\textbf{X}&#39;\textbf{y}]\]</p>

<pre class = 'prettyprint lang-r'>X &lt;- model.matrix(~MRINACount, data = brain)
X &lt;- as.matrix(data.frame(Intercept = 1, MRINACount = brain$MRINACount)) # Аналогичная запись 

Y &lt;- brain$PIQ
betas &lt;- solve(t(X) %*% X) %*% (t(X) %*% Y)
betas</pre>

<pre >##               [,1]
## Intercept  1.74376
## MRINACount 0.00012</pre>

<!-- ##Вычисление вариационно-ковариационной матрицы  -->

<!-- Подобранные параметры - это лишь _оценки_ некоторых параметров, описывающих связь между зависимой переменной и предиктором в популяции.     -->

<!-- Варьирование параметров описывает *вриацонно-ковариационная матрица*.     -->

<!-- В среде `R`, если модель задана, например, с помощью функции `lm()`, эта матрица вычисляется так    -->

<!-- ```{r} -->

<!-- vcov(Mod) -->

<!-- ``` -->

<!-- ##Вычисление вариационо-ковариационной матрицы вручную -->

<!-- $$ -->

<!-- \textbf{V}(\pmb{\beta}) = s^2[\textbf{X}'\textbf{X}]^{-1} -->

<!-- $$ -->

<!-- где -->

<!-- $$ -->

<!-- s^2 = \frac{\sum\limits_{\substack{i=1}}^n e_i^2}{n-k} -->

<!-- $$ -->

<!-- $\sum\limits_{\substack{i=1}}^n e_i^2$ - сумма квадратов остатков    -->

<!-- $n$ - объем выборки    -->

<!-- $k$ - число параметров в модели -->

<!-- ##Вычисление вариационо-ковариационной матрицы вручную -->

<!-- Вычисляем $\sum\limits_{\substack{i=1}}^n e_i^2$    -->

<!-- ```{r} -->

<!-- predict_values <- X %*% betas -->

<!-- resid_values <- cars$dist - predict_values -->

<!-- s2 <- sum(resid_values^2)/(length(resid_values) - length(betas)) -->

<!-- s2 -->

<!-- ``` -->

<!-- ##Вычисление вариационо-ковариационной матрицы вручную -->

<!-- Вычисляем вариационно-ковариационную матрицу -->

<!-- $$ -->

<!-- \textbf{V}(\pmb{\beta}) = s^2[\textbf{X}'\textbf{X}]^{-1} -->

<!-- $$ -->

<!-- ```{r} -->

<!-- covbetas <- s2 * solve(t(X) %*% X) -->

<!-- covbetas -->

<!-- ``` -->

</article></slide><slide class=""><hgroup><h2>Применение матричной алгебры для построения графиков регрессионных моделей</h2></hgroup><article  id="применение-матричной-алгебры-для-построения-графиков-регрессионных-моделей">

<p>Шаг 1. Формируем искусственный датасет со всеми возможными значениями предиктора</p>

<pre class = 'prettyprint lang-r'>MyData &lt;- data.frame(MRINACount = seq(min(brain$MRINACount), max(brain$MRINACount), length.out = 100))
head(MyData)</pre>

<pre >##   MRINACount
## 1     790619
## 2     793537
## 3     796456
## 4     799374
## 5     802293
## 6     805211</pre>

</article></slide><slide class=""><hgroup><h2>Применение матричной алгебры для построения графиков регрессионных моделей</h2></hgroup><article  id="применение-матричной-алгебры-для-построения-графиков-регрессионных-моделей-1">

<p>Шаг 2. Формируем модельную матрицу для искусственно созданных данных</p>

<pre class = 'prettyprint lang-r'>X2 &lt;- model.matrix( ~ MRINACount, data = MyData)
head(X2)</pre>

<pre >##   (Intercept) MRINACount
## 1           1     790619
## 2           1     793537
## 3           1     796456
## 4           1     799374
## 5           1     802293
## 6           1     805211</pre>

</article></slide><slide class=""><hgroup><h2>Применение матричной алгебры для построения графиков регрессионных моделей</h2></hgroup><article  id="применение-матричной-алгебры-для-построения-графиков-регрессионных-моделей-2">

<p>Шаг 3. Вычисляем предсказанные значения для искусственно созданных данных</p>

<pre class = 'prettyprint lang-r'>MyData$Predicted &lt;- X2 %*% betas
head(MyData)</pre>

<pre >##   MRINACount Predicted
## 1     790619      96.8
## 2     793537      97.2
## 3     796456      97.5
## 4     799374      97.9
## 5     802293      98.2
## 6     805211      98.6</pre>

</article></slide><slide class=""><hgroup><h2>Применение матричной алгебры для построения графиков регрессионных моделей</h2></hgroup><article  id="применение-матричной-алгебры-для-построения-графиков-регрессионных-моделей-3">

<p>Шаг 4. Рисуем график</p>

<pre class = 'prettyprint lang-r'>library(ggplot2)
ggplot(MyData, aes(x = MRINACount, y = Predicted)) + geom_line(color = &quot;blue&quot;, size = 1.5) + geom_point(data = brain, aes(x = MRINACount, y = PIQ))</pre>

<p><img src="06_intro_to_linear_algebra_files/figure-html/unnamed-chunk-60-1.png" width="672" style="display: block; margin: auto;" /></p>

<p>Осталось нанести границы доверительной области. Но для этого необходимо ввести понятие <strong>вариационно-ковариационной матрицы</strong></p>

</article></slide><slide class=""><hgroup><h2>Вычисление вариационно-ковариационной матрицы</h2></hgroup><article  id="вычисление-вариационно-ковариационной-матрицы">

<p>Подобранные параметры (вектор коэффициентов) – это лишь <em>оценки</em> некоторых параметров, описывающих связь между зависимой переменной и предиктором в генеральной совокупности.</p>

<p>Варьирование параметров описывает <em>вриацонно-ковариационная матрица</em>.</p>

<p>В среде <code>R</code>, если модель задана, например, с помощью функции <code>lm()</code>, эта матрица вычисляется так</p>

<pre class = 'prettyprint lang-r'>vcov(M_brain)</pre>

<pre >##             (Intercept)     MRINACount
## (Intercept)  1797.11410 -0.00196543266
## MRINACount     -0.00197  0.00000000216</pre>

</article></slide><slide class=""><hgroup><h2>Вычисление вариационо-ковариационной матрицы вручную</h2></hgroup><article  id="вычисление-вариационо-ковариационной-матрицы-вручную">

<p>\[
\textbf{V}_b = s^2[\textbf{X}&#39;\textbf{X}]^{-1}
\] где</p>

<p>\[
s^2 = \frac{\sum\limits_{\substack{i=1}}^n e_i^2}{n-k}
\]</p>

<p>\(\sum\limits_{\substack{i=1}}^n e_i^2\) - сумма квадратов остатков<br/>\(n\) - объем выборки<br/>\(k\) - число параметров в модели</p>

</article></slide><slide class=""><hgroup><h2>Вычисление вариационо-ковариационной матрицы вручную</h2></hgroup><article  id="вычисление-вариационо-ковариационной-матрицы-вручную-1">

<p>Вычисляем \(\sum\limits_{\substack{i=1}}^n e_i^2\)</p>

<pre class = 'prettyprint lang-r'>X &lt;- model.matrix(~MRINACount, data = brain)

predict_values &lt;- X %*% betas

resid_values &lt;- brain$PIQ - predict_values

s2 &lt;- sum(resid_values^2)/(length(resid_values) - length(betas))

s2</pre>

<pre >## [1] 441</pre>

<p>Видели ли мы это число в <code>summary(M_brain)</code>?</p>

<ul class = 'build'>
<li>ДА! это квадрат <code>Residual standard error: 21 on 38 degrees of freedom</code></li>
</ul>

</article></slide><slide class=""><hgroup><h2>Вычисление вариационо-ковариационной матрицы вручную</h2></hgroup><article  id="вычисление-вариационо-ковариационной-матрицы-вручную-2">

<p>Вычисляем вариационно-ковариационную матрицу</p>

<p>\[
\textbf{V}_b = s^2[\textbf{X}&#39;\textbf{X}]^{-1}
\]</p>

<pre class = 'prettyprint lang-r'>covbetas &lt;- s2 * solve(t(X) %*% X)
covbetas</pre>

<pre >##             (Intercept)     MRINACount
## (Intercept)  1797.11410 -0.00196543266
## MRINACount     -0.00197  0.00000000216</pre>

</article></slide><slide class=""><hgroup><h2>Для чего нужна вариационо-ковариационная матрица?</h2></hgroup><article  id="для-чего-нужна-вариационо-ковариационная-матрица">

<p>Она позволяет вычислить значение стандартной ошибки для предсказнных значений (\(\hat{y}\)) для любого значения \(x\)</p>

<p>\[
SE_{\hat y} = \sqrt{diag(\mathbf{X} \times \mathbf{V}_{\mathbf{b}} \times \mathbf{X}&#39;)}
\] \(\mathbf{V}_{\mathbf{b}}\) — вариационно-коварационная матрица для модели</p>

<p>\(\mathbf{X}\) — любая модельная матрица, включающая те же предикторы, что и исходная модель</p>

</article></slide><slide class=""><hgroup><h2>Применение матричной алгебры для построения графиков регрессионных моделей</h2></hgroup><article  id="применение-матричной-алгебры-для-построения-графиков-регрессионных-моделей-4">

<p>Шаг 5. Вычисляем границы доверительных интервалов</p>

<p>Нам известно &ldquo;поведение&rdquo; предсказанных значений (\(\mathbf{\hat{y}}\)). Эти значения лежат на <strong>линии регрессии</strong>.</p>

<p>Значения предиктора описано в модельной матрице \(\textbf{X}\) (для измеренных показателей) или в \(\textbf{X2}\) (для искусственно созданного датасета <code>MyData</code> с возможным варьированием значений предиктора).</p>

<p>Для каждого значения предиктора можно вычислить значение стандартной ошибки:</p>

<p>\[
SE_{\hat y} = \sqrt{diag(\mathbf{X} \times \mathbf{V}_{\mathbf{b}} \times \mathbf{X}&#39;)}
\]</p>

</article></slide><slide class=""><hgroup><h2>Применение матричной алгебры для построения графиков регрессионных моделей</h2></hgroup><article  id="применение-матричной-алгебры-для-построения-графиков-регрессионных-моделей-5">

<p>Шаг 5. Вычисляем границы доверительной зоны регрессии</p>

<pre class = 'prettyprint lang-r'># Вычисляем стандартные отшибки путем перемножения матриц
  MyData$se &lt;- sqrt(diag(X2 %*% covbetas %*% t(X2)))</pre>

<pre class = 'prettyprint lang-r'># Вычисляем доверительные интервалы
MyData$CiUp  &lt;- MyData$Predicted + 1.96 *MyData$se

MyData$CiLow  &lt;- MyData$Predicted - 1.96 *MyData$se</pre>

</article></slide><slide class=""><hgroup><h2>Применение матричной алгебры для построения графиков регрессионных моделей</h2></hgroup><article  id="применение-матричной-алгебры-для-построения-графиков-регрессионных-моделей-6" class="smaller columns-2">

<p>Шаг 6. Строим график</p>

<p><img src="06_intro_to_linear_algebra_files/figure-html/gg-manual-1.png" width="384" style="display: block; margin: auto;" /></p>

<pre class = 'prettyprint lang-r'>ggplot(MyData, aes(x = MRINACount, y = Predicted)) + 
  geom_line(aes(x = MRINACount, y = CiUp),  
            linetype = 2, size = 1) + 
  geom_line(aes(x = MRINACount, y = CiLow), 
            linetype = 2, size = 1) + 
  geom_abline(slope = betas[2], intercept = betas[1], 
              color = &quot;red&quot;) +
  geom_point(data = brain, aes(x = MRINACount, y = PIQ))  </pre>

</article></slide><slide class=""><hgroup><h2>Сравним результаты</h2></hgroup><article  id="сравним-результаты">

<pre >## `geom_smooth()` using formula = &#39;y ~ x&#39;</pre>

<p><img src="06_intro_to_linear_algebra_files/figure-html/unnamed-chunk-66-1.png" width="672" style="display: block; margin: auto;" /></p>

</article></slide><slide class="segue dark nobackground level1"><hgroup class = 'auto-fadein'><h2>Not The End</h2></hgroup><article  id="not-the-end">

<img src='images/matrix2.jpg' title=''/>

</article></slide><slide class=""><hgroup><h2>Что почитать</h2></hgroup><article  id="что-почитать">

<ul>
<li>Legendre P., Legendre L. (2012) Numerical ecology. Second english edition. Elsevier, Amsterdam. Глава 2. Matrix algebra: a summary.</li>
</ul></article></slide>


  <slide class="backdrop"></slide>

</slides>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

<!-- map slide visiblity events into shiny -->
<script>
  (function() {
    if (window.jQuery) {
       window.jQuery(document).on('slideleave', function(e) {
         window.jQuery(e.target).trigger('hidden');
      });
       window.jQuery(document).on('slideenter', function(e) {
         window.jQuery(e.target).trigger('shown');
      });
    }
    if (window.Shiny) {
      // Initialize slides when this script appears on the page, since it
      // indicates that the <slides> markup has been fully loaded.
      window.loadDeck();
    }
  })();
</script>

</body>
</html>
