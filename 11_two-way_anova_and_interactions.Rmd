---
title: "Дисперсионный анализ, часть 2"
subtitle: "Линейные модели..."
author: "Марина Варфоломеева, Вадим Хайтов, Анастасия Лянгузова"
date: "Осень `r format(Sys.Date(), '%Y')`"
output:
  xaringan::moon_reader:
    self_contained: true
    lib_dir: libs
    css: [ninjutsu, "assets/xaringan-themer.css", "assets/xaringan.css"]
    df_print: default
    nature:
      highlightStyle: googlecode
      highlightLines: true
      countIncrementalSlides: false
      titleSlideClass: [middle, left, inverse]
      beforeInit: "assets/macros.js"
    includes:
      in_header: "assets/xaringan_in_header.html"
      after_body: "assets/xaringan_after_body.html"
---

```{r setup, include = FALSE, cache = FALSE, purl = FALSE, fig.showtext = TRUE}
source("assets/xaringan_setup.R")
library(xaringanExtra)
use_tile_view()
use_scribble()
use_search(show_icon = FALSE)
use_progress_bar(color = "#6d2b5e", location = "bottom", height = "10px")
use_freezeframe()
# use_webcam()
# use_panelset()
# use_extra_styles(hover_code_line = TRUE)

# http://tachyons.io/docs/
# https://roperzh.github.io/tachyons-cheatsheet/
use_tachyons()
# use_broadcast()
```

```{r libs, include=FALSE, warning=FALSE}
library("tidyverse")
library("cowplot")
library("ggplot2")
theme_set(theme_bw(base_size = 20))
```

```{r setup1, include = FALSE, cache = FALSE, purl = FALSE}
options(knitr.kable.NA = '')
source("support_linmodr.R")
```


## Многофакторный дисперсионный анализ

- Модель многофакторного дисперсионного анализа;
- Взаимодействие факторов;
- Несбалансированные данные, типы сумм квадратов;
- Многофакторный дисперсионный анализ в R;
- Дисперсионный анализ в матричном виде.

### Вы сможете

- Проводить многофакторный дисперсионный анализ и интерпретировать его результаты с учётом взаимодействия факторов.


---

class: middle, center, inverse

# One Way ANOVA Update: параметризация модели и контрасты

---

## Открываем данные

```{r, data-eggs}
library(DAAG)
data("cuckoos")
# Положим данные в переменную с коротким названием, чтобы меньше печатать
eggs <- cuckoos
head(eggs, 3)
# Сократим названия переменных
colnames(eggs) <- c('len', 'br', 'sp', 'id')
```

---

## Изменим названия уровней фактора, чтобы было легче понять о каких птицах речь

```{r, tidy=FALSE}
levels(eggs$sp)
levels(eggs$sp) <- c("ЛесЗав", "ЛугКон", "БелТряс", 
                        "Малин", "ЛесКон", "Крапив")
```



```{r echo=FALSE, eval=FALSE}
library(ggplot2)
theme_set(theme_bw())
```


---

## Для кодирования дискретных факторов в R используются две параметризации

.pull-left[

__Параметризация индикаторных переменных__

Так же известна как

- dummy coding
- treatment parametrisation
- reference cell model

<br/>

- В R обозначается __contr.treatment__.

С ней вы уже знакомы. 

Используется по умолчанию в R.

]

--

.pull-right[

__Параметризация эффектов__ <br/><br/>

Так же известна как

- effects coding
- sum-to-zero parameterisation

- В R обозначается __contr.sum__.

"Классическая" параметризация для дисперсионного анализа. 

Нужна, если изначально предполагается, что факторы взаимодействуют и взаимодействия мы удалять не собираемся. В этой ситуации придется использовать III тип сумм квадратов.


- SS(A | B, AB) для фактора A. 

- SS(B | A, AB) для фактора B


]

---

class: middle, center, inverse

# Параметризация индикаторных переменных

---

## Переменные-индикаторы

Фрагмент модельной матрицы:

sp | spЛугКон <br/> $x_1$ | spМалин <br/> $x_2$ | spБелТряс <br/> $x_3$ | spЛесКон <br/> $x_4$ | spЛесЗав <br/> $x_5$
---- | ---- | ---- | ---- | ---- | ---- 
Крапив   |  |  |  |  | 
ЛугКон   |  |  |  |  | 
Малин    |  |  |  |  | 
БелТряс  |  |  |  |  | 
ЛесКон   |  |  |  |  | 
ЛесЗав   |  |  |  |  | 

---

## Переменные-индикаторы

Фрагмент модельной матрицы:

sp | spЛугКон <br/> $x_1$ | spМалин <br/> $x_2$ | spБелТряс <br/> $x_3$ | spЛесКон <br/> $x_4$ | spЛесЗав <br/> $x_5$
---- | ---- | ---- | ---- | ---- | ---- 
Крапив   | 0 | 0 | 0 | 0 | 0
ЛугКон   | 1 | 0 | 0 | 0 | 0
Малин    | 0 | 1 | 0 | 0 | 0
БелТряс  | 0 | 0 | 1 | 0 | 0
ЛесКон   | 0 | 0 | 0 | 1 | 0
ЛесЗав   | 0 | 0 | 0 | 0 | 1

Переменных-индикаторов всегда на одну меньше, чем число уровней фактора.

Уровень "`r levels(eggs$sp)[1]`" будет базовым: для его кодирования не нужна отдельная переменная.

---

## Коэффициенты модели в параметризации индикаторов


.pull-left-60[

Фрагмент модельной матрицы:
.small[
sp | spЛугКон <br/> $x_1$ | spМалин <br/> $x_2$ | spБелТряс <br/> $x_3$ | spЛесКон <br/> $x_4$ | spЛесЗав <br/> $x_5$
---- | ---- | ---- | ---- | ---- | ---- 
Крапив   | 0 | 0 | 0 | 0 | 0
ЛугКон   | 1 | 0 | 0 | 0 | 0
Малин    | 0 | 1 | 0 | 0 | 0
БелТряс  | 0 | 0 | 1 | 0 | 0
ЛесКон   | 0 | 0 | 0 | 1 | 0
ЛесЗав   | 0 | 0 | 0 | 0 | 1
]
]

.pull-right-40[


```{r mod-trt, echo=FALSE, purl=FALSE}
mod_treatment <- lm(len ~ sp, data = eggs)
```

```{r echo=FALSE, purl=FALSE, opts.label='fig.medium.taller'}

gg_means <- ggplot(data = eggs, aes(x = sp, y = len, colour = sp)) + 
  stat_summary(geom = "pointrange", fun.data = mean_cl_normal, size = 1) +
  labs(x = "Вид хозяев", y = "Длина яиц кукушек, мм") + 
  scale_colour_brewer(name = "Вид \nхозяев", palette = "Dark2") + 
  theme(legend.position = "none")


cft <- round(coef(mod_treatment), 2)
ar <- arrow(angle = 15, length = unit(3, "mm"), ends = "both", type = "closed")
art <-  arrow(angle = 15, length = unit(3, "mm"), ends = "last", type = "closed")
gg_means +
  geom_hline(yintercept = cft[1], linetype = "dashed") +
  annotate("segment", x = 0.75, y = -Inf, 
           xend = 0.75, yend = cft[1], arrow = art) +
  annotate("text", x = 0.75, y = cft[1], label = "b[0]", 
           vjust = 0, parse = T, size = 7) +
  
  annotate("segment", x = 1.75, y = cft[1], 
           xend = 1.75, yend = cft[1] + cft[2], arrow = ar) +
  annotate("text", x = 1.75, y = cft[1] + cft[2], label = "b[1]", 
           vjust = 0, parse = T, size = 7) +
  
  annotate("segment", x = 2.75, y = cft[1], 
           xend = 2.75, yend = cft[1] + cft[3], arrow = ar) +
  annotate("text", x = 2.75, y = cft[1]+ cft[3], label = "b[2]", 
           vjust = 0, parse = T, size = 7) +
  
  annotate("segment", x = 3.75, y = cft[1], 
           xend = 3.75, yend = cft[1] + cft[4], arrow = ar) +
  annotate("text", x = 3.75, y = cft[1]+ cft[4], label = "b[3]", 
           vjust = 0, parse = T, size = 7) +
  
  annotate("segment", x = 4.75, y = cft[1], 
           xend = 4.75, yend = cft[1] + cft[5], arrow = ar)+
  annotate("text", x = 4.75, y = cft[1]+ cft[5], label = "b[4]", 
           vjust = 0, parse = T, size = 7) +
  
  annotate("segment", x = 5.75, y = cft[1], 
           xend = 5.75, yend = cft[1] + cft[6], arrow = ar) +
  annotate("text", x = 5.75, y = cft[1]+ cft[6], label = "b[5]", 
           vjust = 0, parse = T, size = 7)
```

]

.pull-down[
$$y _{i} = b_0 + b_1 x _{1i} + \ldots + b_5 x_{5i} + e_{i}$$


- $b_0$ --- это среднее значение отклика для базового уровня фактора.
- $b_1, ..., b_5$ --- это отклонения от базового уровня для средних с другими уровнями фактора.

]

---

## Подбор модели в параметризации индикаторов

```{r mod-trt, echo=TRUE, purl=TRUE}
```

```{r}
round(coef(mod_treatment), 2)
```

$$\widehat{len}_i = 21.12 + 1.17 sp_{\text{ЛугКон}\ i} + 1.44 sp_{\text{Малин}\ i} + 1.77 sp_{\text{БелТряс}\ i} + \\ + 1.96 sp_{\text{ЛесКон}\ i} + 1.99 sp_{\text{ЛесЗав}\ i}$$


---

## Уравнение модели в параметризации индикаторов

$$\widehat{len}_i = 21.12 + 1.17 sp_{\text{ЛугКон}\ i} + 1.44 sp_{\text{Малин}\ i} + 1.77 sp_{\text{БелТряс}\ i} + \\ + 1.96 sp_{\text{ЛесКон}\ i} + 1.99 sp_{\text{ЛесЗав}\ i}$$

Первый коэффициент --- средний размер яиц кукушек в гнездах крапивников (на базовом уровне):

- $\widehat{len}_{\text{Крапив}} = `r cft[1]`$

Другие коэффициенты --- разница размеров яиц кукушек в гнездах крапивников и других хозяев (отклонения от базового уровня).

Если их прибавить к базовому уровню, то получим предсказанные значения для других видов:

- $\widehat{len}_{\text{ЛугКон}\ i} = 21.12 + 1.17 sp_{\text{ЛугКон}\ i} = `r sum(cft[1:2])`$
- $\widehat{len}_{\text{Малин}\ i} = 21.12 + 1.44 sp_{\text{Малин}\ i} = `r sum(cft[c(1, 3)])`$
- $\widehat{len}_{\text{БелТряс}\ i} = 21.12 + 1.77 sp_{\text{БелТряс}\ i} = `r sum(cft[c(1, 4)])`$
- $\widehat{len}_{\text{ЛесКон}\ i} = 21.12 + 1.96 sp_{\text{ЛесКон}\ i}= `r sum(cft[c(1, 5)])`$
- $\widehat{len}_{\text{ЛесЗав}\ i} = 21.12 + 1.99 sp_{\text{ЛесЗав}\ i} = `r sum(cft[c(1, 6)])`$

---

class: middle, center, inverse

# Параметризация эффектов

---

## Другая точка отсчета

В качестве референса можно использовать не базовый уровень, а общее среднее значение.


```{r mod-sum1, echo=FALSE, purl=FALSE}
mod_sum <- lm(len ~ sp, data = eggs, contrasts = list(sp = contr.sum))
```

```{r echo=FALSE, purl=FALSE, opts.label='fig.wider.taller'}
cfs <- round(coef(mod_sum), 2)

gg_means +
  coord_cartesian(xlim = c(0.25, 6)) +
  geom_hline(yintercept = cfs[1], linetype = "dashed") 
```


---

## Переменные-эффекты

Фрагмент модельной матрицы:

sp | sp1 <br/> $x_1$ | sp2 <br/> $x_2$ | sp3 <br/> $x_3$ | sp4 <br/> $x_4$ | sp5 <br/> $x_5$
---- | ---- | ---- | ---- | ---- | ----
Крапив   |  |   |   |   |  
ЛугКон   |  |   |   |   |  
Малин    |  |   |   |   |  
БелТряс  |  |   |   |   |  
ЛесКон   |  |   |   |   |  
ЛесЗав   |  |   |   |   | 



Переменных-эффектов всегда на одну меньше, чем число уровней фактора.

Переменные закодированы при помощи -1, 0 и 1 (сумма кодов для возможных состояний одной переменной равна нулю).

Для последней группы все переменные-эффекты будут равны $-1$.

---

## Переменные-эффекты

Фрагмент модельной матрицы:

sp | sp1 <br/> $x_1$ | sp2 <br/> $x_2$ | sp3 <br/> $x_3$ | sp4 <br/> $x_4$ | sp5 <br/> $x_5$
---- | ---- | ---- | ---- | ---- | ----
Крапив   |  1 |  0  |  0 |  0 |  0
ЛугКон   |  0 |  1  |  0 |  0 |  0
Малин    |  0 |  0  |  1 |  0 |  0
БелТряс  |  0 |  0  |  0 |  1 |  0
ЛесКон   |  0 |  0  |  0 |  0 |  1
ЛесЗав   | -1 | -1  | -1 | -1 | -1

Переменных-эффектов всегда на одну меньше, чем число уровней фактора.

Переменные закодированы при помощи -1, 0 и 1 (сумма кодов для возможных состояний одной переменной равна нулю).

Для последней группы все переменные-эффекты будут равны $-1$.

---

## Коэффициенты модели в параметризации эффектов

.pull-left[
Фрагмент модельной матрицы:

sp | sp1 <br/> $x_1$ | sp2 <br/> $x_2$ | sp3 <br/> $x_3$ | sp4 <br/> $x_4$ | sp5 <br/> $x_5$
---- | ---- | ---- | ---- | ---- | ----
Крапив   |  1 |  0  |  0 |  0 |  0
ЛугКон   |  0 |  1  |  0 |  0 |  0
Малин    |  0 |  0  |  1 |  0 |  0
БелТряс  |  0 |  0  |  0 |  1 |  0
ЛесКон   |  0 |  0  |  0 |  0 |  1
ЛесЗав   | -1 | -1  | -1 | -1 | -1

]

.pull-right[

```{r mod-sum, echo=FALSE, purl=FALSE}
mod_sum <- lm(len ~ sp, data = eggs, contrasts = list(sp = contr.sum))
```

```{r echo=FALSE, purl=FALSE, opts.label='fig.wider.taller'}
cfs <- round(coef(mod_sum), 2)

gg_means +
  coord_cartesian(xlim = c(0.25, 6)) +
  geom_hline(yintercept = cfs[1], linetype = "dashed") +
  annotate("text", x = 0.25, y = cfs[1], label = "b[0]", 
           vjust = - 0.1, hjust = 1.35, parse = T, size = 7) +
  annotate("segment", x = 0.25, y = -Inf, 
           xend = 0.25, yend = cfs[1], arrow = art) +
  
  
  annotate("segment", x = 0.75, y = cfs[1], 
           xend = 0.75, yend = cfs[1] + cfs[2], arrow = ar) +
  annotate("text", x = 0.75, y = cfs[1], label = "b[1]", 
           vjust = - 0.1, hjust = 1.35, parse = T, size = 7) +
  
  annotate("segment", x = 1.75, y = cfs[1], 
           xend = 1.75, yend = cfs[1] + cfs[3], arrow = ar) +
  annotate("text", x = 1.75, y = cfs[1], label = "b[2]", 
           vjust = - 0.1, hjust = 1.35, parse = T, size = 7) +
  
  annotate("segment", x = 2.75, y = cfs[1], 
           xend = 2.75, yend = cfs[1] + cfs[4], arrow = ar) +
  annotate("text", x = 2.75, y = cfs[1], label = "b[3]", 
           vjust = - 0.1, hjust = 1.35, parse = T, size = 7) +
  
  annotate("segment", x = 3.75, y = cfs[1], 
           xend = 3.75, yend = cfs[1] + cfs[5], arrow = ar) +
  annotate("text", x = 3.75, y = cfs[1], label = "b[4]", 
           vjust = - 0.1, hjust = 1.35, parse = T, size = 7) +
  
  annotate("segment", x = 4.75, y = cfs[1], 
           xend = 4.75, yend = cfs[1] + cfs[6], arrow = ar)+
  annotate("text", x = 4.75, y = cfs[1], label = "b[5]", 
           vjust = - 0.1, hjust = 1.35, parse = T, size = 7) +
  
  annotate("segment", x = 5.75, y = cfs[1], 
           xend = 5.75, yend = cfs[1] - sum(cfs[-1]), arrow = ar) +
  annotate("text", x = 5.75, y = cfs[1], 
           label = "-b[2]-b[3]-b[4]-b[5]", 
           vjust = 1.25, hjust = 0.75, parse = T, size = 7)
```

]


.pull-down[

$$y _{i} = b_0 + b_1 x _{1i} + \ldots + b_5 x_{5i} + e_{i}$$

- $b_0$ --- это общее среднее значение отклика.
- $b_1, ..., b_5$ --- это отклонения от общего среднего для средних с другими уровнями фактора, кроме последнего.
- для последнего уровня фактора отклонения от общего среднего --- это коэффициенты $b_1, ..., b_5$, взятые с противоположным знаком.
]

---

## Подбор модели в параметризации эффектов

```{r mod-sum, echo=TRUE, purl=TRUE}
```

```{r purl=TRUE}
round(coef(mod_sum), 2)
```

Коэффициенты моделей в разных параметризациях будут разными, но предсказания будут совершенно одинаковыми.

$$\widehat{len}_i = 22.51 -1.39 sp_{1\ i} -0.22 sp_{2\ i} + 0.05 sp_{3\ i} + 0.38 sp_{4\ i} + 0.57 sp_{5\ i}$$

---

## Уравнение модели в параметризации эффектов


$$\widehat{len}_i = 22.51 -1.39 sp_{1\ i} -0.22 sp_{2\ i} + 0.05 sp_{3\ i} + 0.38 sp_{4\ i} + 0.57 sp_{5\ i}$$

Первый коэффициент --- средний размер яиц кукушек по всем данным:

- $\overline{len} = `r cfs[1]`$

Другие коэффициенты — отличие размеров яиц в гнездах хозяев от общего среднего. Для всех уровней, кроме последнего — без изменения знака:

- $\widehat{len}_{\text{Крапив}\ i} = 22.51 -1.39 sp_{1\ i} = `r sum(cfs[1:2])`$
- $\widehat{len}_{\text{ЛугКон}\ i} = 22.51 -0.22 sp_{2\ i} = `r sum(cfs[c(1, 3)])`$
- $\widehat{len}_{\text{Малин}\ i} = 22.51 + 0.05 sp_{3\ i} = `r sum(cfs[c(1, 4)])`$
- $\widehat{len}_{\text{БелТряс}\ i} = 22.51 + 0.38 sp_{4\ i} = `r sum(cfs[c(1, 5)])`$
- $\widehat{len}_{\text{ЛесКон}\ i} = 22.51 + 0.57 sp_{5\ i} = `r sum(cfs[c(1, 6)])`$

Для последнего уровня фактора — с противоположным знаком,  
т.к. для него все переменные-эффекты $sp_1,..., sp_5 = -1$:

- $\widehat{len}_{\text{ЛесЗав}\ i} = 22.51 -1.39 sp_{1\ i} -0.22 sp_{2\ i} + 0.05 sp_{3\ i} + 0.38 sp_{4\ i} + 0.57 sp_{5\ i} = `r cfs[1] + sum(-cfs[2:6])`$


---

class: middle, center, inverse

## Линейные контрасты

---

## Применение линейных контрастов

Когда нам нужны только какие-то определённые группы сравнения, а не все группы со всеми сразу. Модель сравнения записывается в форме модельной матрицы. Для начала разберёмся со сравнением двуx групп в модели, заданной параметризацией индикаторов. 

Допустим, мы хотим сравнить лугового конька с белой трясогузкой. Возьмём лугового конька в качестве референсной группы. В таком случае можно оценить контраст для неё как: $L_1 = 1 * b_{ЛугКон} = 1 * b_{ЛугКон} + 0 * b_{БелТряс}$. Данное значение будет идентично интерсепту в R. 

Контраст для второй группы сравнения можно записать как разница между средним значением в ней и референсным значением: $L_2 = 1 * b_{БелТряс} - 1 * b_{ЛугКон}$.

Таким образом, получаем матрицу следующего вида: 

<div class="math">
\[
\begin{array}{cc} &
\begin{vmatrix}
1 & 0 \\
1 & -1
\end{vmatrix}\end{array}
\]
</div>
---

## Линейные контрасты

Так же, как в случае записи модельной матрицы, такая полная запись несколько излишня, поскольку нас интересует только та часть матрицы, которая соответствует __сравнению__ между двумя группами. Т.е. БелТряс --- ЛугКон =

<div class="math">
\[
\begin{array}{cc} &
\begin{vmatrix}
1 & -1
\end{vmatrix}\end{array}
\]
</div>

__НО!__ В нашем датасете гораздо больше групп сравнения, и нас может интересовать большее количество групп. Например, хотим ещё сравнить размер лугового конька с лесной завирушкой. 

Уравнение для данного случая можно записать следующим образом: 
 $$\textit{БелТряс} - \textit{ЛугКон} = 0$$

 $$\textit{ЛесЗав} - \textit{ЛугКон} = 0$$

---

## Запись линейных контрастов текстом в R

```{r linear-contr-text}
library(multcomp)

eggs_contrtext <- glht(mod_treatment,
                    linfct = mcp(sp = c("БелТряс - ЛугКон = 0",
                                        "ЛесЗав - ЛугКон = 0")))

summary(eggs_contrtext)
```

---

## Запись матрицы контрастов с несколькими группами сравнения 

В нашиx данныx несколько видов птиц, сначала нужно записать уравнение с учётом каждого значения фактора.

Уравнение для длины яиц в гнездах белой трясогузки:
$$Y_{БелТряс} = 1 * b_0       + 0 * b_{ЛугКон} + 0 * b_{Малин} + \\ + 1 * b_{БелТряс} + 0 * b_{ЛесКон} + 0 * b_{ЛесЗав}$$
в гнездах лугового конька:
$$Y_{ЛугКон}  = 1 * b_0       + 1 * b_{ЛугКон} + 0 * b_{Малин} + \\ + 0 * b_{БелТряс} + 0 * b_{ЛесКон} + 0 * b_{ЛесЗав}$$
в гнездах лесной завирушки:
$$Y_{ЛесЗав}  = 1 * b_0       + 0 * b_{ЛугКон} + 0 * b_{Малин} + \\ + 0 * b_{БелТряс} + 0 * b_{ЛесКон} + 1 * b_{ЛесЗав}$$

Для сравнения групп так же вычитаем члены одного уравнения из другого.

---

## Запись матрицы контрастов с несколькими группами сравнения 

Например, для сравнения белой трясогузки и лугового конька.

$$БелТряс - ЛугКон = 0 * b_0 - 1 * b_{ЛугКон} + 0 * b_{Малин} + \\ + 1 * b_{БелТряс} + 0 * b_{ЛесКон} + 0 * b_{ЛесЗав}$$

Лесной завирушки и лугового конька:

$$ЛесЗав - ЛугКон = 0 * b_0 - 1 * b_{ЛугКон} + 0 * b_{Малин} + \\ + 0 * b_{БелТряс} + 0 * b_{ЛесКон} + 1 * b_{ЛесЗав}$$

---

## Запись матрицы контрастов в R 

В случае когда у нас, например, две группы сравнения: $\textit{БелТряс} - \textit{ЛугКон}$ и $\textit{ЛесЗав} - \textit{ЛугКон}$, матрица контрастов будет выглядеть на наших данных следующим образом.

<div class="math">
\[
\begin{array}{cc} &
\begin{vmatrix}
0 & -1 & 0 & 1 & 0 & 0 \\
0 & -1 & 0 & 0 & 0 & 1
\end{vmatrix}\end{array}
\]
</div>

Код будет выглядеть следующим образом: 
```{r matrix-linear-contr}
contr <- rbind("БелТряс - ЛугКон" = c(0, -1, 0, 1, 0, 0),
               "ЛесЗав - ЛугКон" = c(0, -1, 0, 0, 0, 1))
eggs_contrmat <- glht(mod_treatment, linfct = contr)
summary(eggs_contrmat)
```

---





class: middle, center, inverse

# Данные, связанные с двумя факторами

---

## Пример: Пингвины 

Зависит ли вес пингвина от его видовой принадлежности и пола?

.pull-left[Измерения особей пингвинов из рода *Pygoscelis* лежат в датасете `penguins` в пакете `palmerpenguins`. Исходные данные были опубликованы в работе Gorman et al., 2014. Помимо веса и пола животных, датасет содержит информацию об острове, на котором пингвины проживали, и измерения клюва. В анализ мы возьмём только следующие переменные:


Зависимая переменная:

- `body_mass_g` --- вес в граммах.

Факторы:

- `species` --- вид пингвина;
- `sex` --- пол пингвина.]

.pull-right[
![](images/penguin.jpg)
.small[
.pull-right[On [Pinterest](https://www.pinterest.com/pin/explore-the-natural-world--153544668520878653/)]
]
]

---

## Знакомимся с данными

```{r}
# Открываем данные
library(palmerpenguins)
peng <- as.data.frame(penguins[, c(1, 6, 7)]) 
str(peng)
# Переименовываем столбцы
colnames(peng) <- c('sp', 'mass', 'sex')
```

---

## Пропущенные значения

```{r}
colSums(is.na(peng))
```

Удаляем пропущенные значения (каких-то пингвинов не измерили :()

```{r}
pengs <- peng[complete.cases(peng), ]
colSums(is.na(pengs))
```

---

## Объемы выборок в группах

```{r}
table(pengs$sp, pengs$sex)
```

--

- Группы разного размера

---

##   Посмотрим на график

```{r gg-mean-ci}
library(ggplot2)
theme_set(theme_bw(base_size = 14))
gg_mass <- ggplot(data = pengs, aes(x = sp, y = mass, colour = sex)) + 
  stat_summary(geom = 'pointrange', fun.data = mean_cl_normal)
gg_mass
```

---

class: middle, center, inverse

# Многофакторный дисперсионный анализ

---

## Многофакторный дисперсионный анализ

Дисперсионный анализ становится многофакторным, если в модели используется несколько дискретных факторов.

Дизайн такого рода анализа может быть разным. 

--

.pull-left[
### Вложенные (иерархичные) модели

В модели внутри какого-то фактора расположены дополнительные предикторы. Особенность таких моделей в том, что категории вложенных факторов в пределах уровней основного фактора различны. 

**Пример:** измерения обилия беспозвоночных животных на литорали в разные годы и месяцы. 
]

--

.pull-right[
### Факторные модели

Дизайн эксперимента предполагает, что разные факторы пересекаются друг с другом. Таким образом возможны любые комбинации между разными уровнями разных факторов. 

Наш случай! Факторов может быть несколько, мы будем разбираться на примере двухфакторного дисперсионного анализа.
]

---

## Какие бывают факторы

Свойства | Фиксированные факторы | Случайные факторы
---- | ---- | ----
Уровни фактора | фиксированные, заранее определенные и потенциально воспроизводимые уровни | случайная выборка из всех возможных уровней
Используются для тестирования гипотез | о средних значениях отклика между уровнями фактора <br/> $H _{0}: \mu _1 = \mu _2 = \ldots = \mu _i = \mu$ | о дисперсии отклика между уровнями фактора <br/> $H _{0}: \sigma_{rand.fact.}^2 = 0$
Выводы можно экстраполировать | только на уровни из анализа | на все возможные уровни

Мы сейчас работает с фиксированными факторами. В случае, когда в модели присутстуют и фиксированные, и случайные факторы --- используют смешанные линейные модели, о которых мы поговорим позже. 

---

## Взаимодействие факторов

При добавлении новых факторов в модель появляется **взаимодействие** факторов.

Взаимодействие факторов возникает, когда у одного фактора эффект разный в зависимости от уровней другого.

Такое взаимодействие необходимо учитывать, в т.ч. при интепретации результатов.

---

## Что такое взаимодействие дискретных предикторов

Взаимодействие факторов --- когда эффект фактора B разный в зависимости от уровней фактора A и наоборот.

На каких рисунках есть взаимодействие факторов? (.small[Logan, 2010, fig.12.2])

.pull-left[


![interaction](images/interaction.png)

]

--

.pull-right[

- b, c - нет взаимодействия (эффект фактора B одинаковый для групп по фактору A, линии для разных групп по фактору B на графиках расположены параллельно)
- a, d - есть взаимодействие (эффект фактора B разный для групп по фактору A, на графиках линии для разных групп по фактору B расположены под наклоном).

]

---

## Влияют ли главные эффекты и взаимодействие?

![interaction_a](images/interaction1a.png)
.small[Quinn, Keough, 2002, fig.9.3]

--

- взаимодействие не значимо, и не мешает интерпретировать эффекты факторов.
  - фактор А влияет
  - фактор В влияет

---

## Влияют ли главные эффекты и взаимодействие?

![interaction_b](images/interaction1b.png)

.small[Quinn, Keough, 2002, fig.9.3]

--

- взаимодействие значимо и мешает интерпретировать влияние факторов отдельно:
    - для В2 зависимая переменная возрастает с изменением уровня А
    - для В1 зависимая переменная возрастает только на А2, но не различается на А1 и А3
- __если смотреть на главные эффекты, можно сделать неправильные выводы (о факторе А)__:
    - фактор А влияет, группы А2 и А3 не отличаются
    - фактор В влияет, в группе В2 зависимая переменная больше, чем в В1


---

## Влияют ли главные эффекты и взаимодействие?

![interaction_c](images/interaction1c.png)

.small[Quinn, Keough, 2002, fig.9.3]

--

- взаимодействие значимо и мешает интерпретировать влияние факторов отдельно:
    - на уровне A2 меняется порядок различий уровней фактора B
- __если смотреть на главные эффекты, можно сделать неправильные выводы__:
    - факторы А и В не влияют


---

## Взаимодействие факторов может маскировать главные эффекты

.pull-left[

![interaction](images/interaction1.png)

.small[Quinn, Keough, 2002, fig.9.3]

]

.pull-right[

Если есть значимое взаимодействие, то 
- главные эффекты обсуждать  не имеет смысла  
- пост хок тесты проводятся только для взаимодействия
]

---

class: middle, center, inverse

# Двухфакторный дисперсионный анализ <br/> в параметризации индикаторов

---

## Переменные-индикаторы

В нашем примере отклик --- вес пингвина, и два дискретных фактора: 

- `sex` --- 2 уровня (базовый `female`), для кодирования нужна одна переменная.
```{r}
contr.treatment(levels(pengs$sex))
```

-  `sp` --- 3 уровня (базовый `Adelie`), для кодирования нужно две переменных.

```{r}
contr.treatment(levels(pengs$sp))
```

---

## Переменные-индикаторы

Дополнительные переменные понадобятся, чтобы учесть взаимодействие факторов.

Фрагмент модельной матрицы:

sex <br/>  | sp <br/>  | sexsp <br/>  $x_1$  | spChinstrap <br/> $x_2$ | spGentoo <br/> $x_3$| sexmale:Chinstrap <br/> $x_4$ | sexmale:Gentoo <br/> $x_5$
---- | ---- | ---- | ---- | ---- | ---- | ---- 
female   |  Adelie   | 0 | 0 | 0 | 0 | 0          
male  |  Adelie   | 1 | 0 | 0 | 0 | 0
female   |  Chinstrap   | 0 | 1 | 0 | 0 | 0          
male  |  Chinstrap   | 1 | 1 | 0 | 1 | 0
female   |  Gentoo   | 0 | 0 | 1 | 0 | 0          
male  |  Gentoo   | 1 | 0 | 1 | 0 | 1

---

## Уравнение линейной модели в параметризации индикаторов

$$y _{i} = b _0 + b _1 x _{1i} + b _2 x _{2i} + b _3 x _{3i} + b _4 x _{4i} + b _5 x _{5i}+ e _{i}$$


- $b_0$ --- значение отклика для самок вида Adelie (на базовом уровне обоих факторов).

Отклонения относительно базового уровня обоих факторов:

- $b_1$ --- для самцов Adelie;
- $b_2$ и $b_3$ --- для самок Chinstrap и Gentoo, соответственно;
- $b_4$ и $b_5$ --- для самцов Chinstrap и Gentoo, соответственно.

---

## Подбираем линейную модель <br/> в параметризации индикаторов (contr.treatment)

```{r purl=FALSE}
mod_treat_pengs <- lm(mass ~ sex * sp, data = pengs) 
mod_treat_pengs
```

Общее уравнение модели

$$\begin{aligned}\widehat{mass} _{i} = 3369 + 675 sex_{male,i} + 158 sp_{Chinstrap\,i} + 1311 sp_{Gentoo\,i} + \\ - 263 sex_{male}\ sp_{Chinstrap\,i} + 130 sex_{male}\ sp_{Gentoo\,i} \end{aligned}$$

---

class: middle, center, inverse

# Двухфакторный дисперсионный анализ в параметризации эффектов

---

## Переменные-эффекты

В нашем примере отклик --- вес пингвина, и два дискретных фактора: 

- `sex` --- 2 уровня (базовый `female`), для кодирования нужна одна переменная.

```{r}
contr.sum(levels(pengs$sex))
```

-  `sp` --- 3 уровня (базовый `Adelie`), для кодирования нужно две переменных.

```{r}
contr.sum(levels(pengs$sp))
```

---

## Переменные-эффекты

Дополнительные переменные понадобятся, чтобы учесть взаимодействие факторов.

Фрагмент модельной матрицы:

sex <br/>  | sp <br/>  | sex1 <br/> $x_1$ | sp1 <br/> $x_2$ | sp2 <br/> $x_3$ | sex1:sp1 <br/> $x_4$ | sex1:sp2 <br/> $x_5$
:---- | :----: | :----: | :----: | :----: | :----: | :----:
female   |  Adelie   |  1 |  1 |  0 |  1 |  0           
male  |  Adelie   | -1 |  1 |  0 | -1 |  0 
female   |  Chinstrap   |  1 |  0 |  1 |  0 |  1           
male  |  Chinstrap   | -1 |  0 |  1 |  0 | -1 
female   |  Gentoo   |  1 | -1 | -1 | 1 | 1           
male  |  Gentoo   | -1 | -1 | -1 |  -1 |  -1 

---

## Уравнение линейной модели в параметризации эффектов

$$y _{i} = b _0 + b _1 x _{1i} + b _2 x _{2i} + b _3 x _{3i} + b _4 x _{4i} + b _5 x _{5i}+ e _{i}$$

- $b_0$ --- среднее значение отклика по всем данным.

Отклонения от общего среднего значений отклика:

- $b_1$ --- в зависимости от пола (фактор `sex`);
- $b_2$ и $b_3$ --- в зависимости от вида (фактор `sp`);
- $b_4$ и $b_5$ --- для пола в зависимости от вида  (взаимодействие).

---

## Подбираем линейную модель <br/> в параметризации эффектов (contr.sum)

```{r purl=FALSE}
mod_sum_pengs <- lm(mass ~ sex * sp, data = pengs, 
                    contrasts = list(sp = 'contr.sum', sex = 'contr.sum')) 
coef(mod_sum_pengs)
```

Общее уравнение модели

$$\begin{aligned}\widehat{mass}_i = 417.85 - 315.25 sex_{female\,i} - 467.68 sp_{Adelie\,i} - 440.76 sp_{Chinstrap\,i} - \\ - 22.08 sex_{female\,i}sp_{Adelie\,i} + 109.37 sex_{female\,i}sp_{Chinstrap\,i} \end{aligned}$$

---

class: middle, center, inverse

# Диагностика линейной модели

---

## Диагностика линейной модели 

Нужно проверить, выполняются ли условия применимости <br/> для модели в нужной параметризации

Данные для анализа остатков

```{r R.options=list(width = 60)}
mod_treat_peng_diag <- fortify(mod_treat_pengs) # функция из пакета ggplot2
head(mod_treat_peng_diag, 2)
```

---

## График расстояния Кука

```{r cooksd}
ggplot(mod_treat_peng_diag, aes(x = 1:nrow(mod_treat_peng_diag), y = .cooksd)) +
  geom_bar(stat = 'identity')
```

--

- Влиятельных наблюдений нет.

---

## График остатков от предсказанных значений


```{r resid-fitted}
gg_resid <- ggplot(data = mod_treat_peng_diag, aes(x = .fitted, y = .stdresid)) +
  geom_point() + geom_hline(yintercept = 0)
gg_resid
```

--

- Влиятельных наблюдений нет (все в пределах 3 SD). 

- Несколько наблюдений не совсем обычны (2SD < .stdresid < 3SD), но поскольку расстояние Кука для них небольшое, это нестрашно.

---

## График зависимости остатков от предикторов в модели


```{r resid-predictors}
ggplot(data = mod_treat_peng_diag, aes(x = sex, y = .stdresid, colour = sp)) +
  geom_boxplot() + geom_hline(yintercept = 0)
```


Удобнее смотреть на боксплот. Нет гетерогенности дисперсии, всё хорошо!



---

## Квантильный график остатков

```{r qq-plot, echo=TRUE, purl=TRUE, eval=FALSE}
library(car)
qqPlot(mod_treat_pengs, id = FALSE) # функция из пакета car
```

```{r qq-plot1, echo=FALSE, purl=FALSE, fig.width=5.5, fig.height=3.5}
library(car)
op <- par(mar = c(3, 3, 0.5, 0.5))
qqPlot(mod_treat_pengs, id = FALSE)
par(op)
```

--

- Отклонений от нормального распределения нет.

---

class: middle, center, inverse

# Несбалансированные данные, типы сумм квадратов

---

## Несбалансированные данные - когда численности в группах по факторам различаются

.pull-left[

Например так,

|    | A1 | A2 | A3 |
|----|----|----|----|
| B1 |  5 | 5  |  5 |
| B2 |  5 | 4  |  5 |

]

.pull-right[

или так,


|    | A1 | A2 | A3 |
|----|----|----|----|
| B1 |  3 | 8  |  4 |
| B2 |  4 | 7  |  4 |

]

---

## Проблемы из-за несбалансированности данных

- Оценки средних в разных группах с разным уровнем точности (Underwood 1997)

- ANOVA менее устойчив к отклонениям от условий применимости (особенно от __гомогенности__ дисперсий) при разных размерах групп (Quinn Keough 2002, section 8.3)

- Проблемы с расчетом мощности. Если $\sigma _{\epsilon}^2 > 0$ и размеры выборок разные, то $MS _{x} \over MS _{e}$ не следует F-распределению (Searle et al. 1992).  


<br/>

--

Старайтесь _планировать_ группы равной численности!
Но если не получилось --- не страшно:
- Для фиксированных эффектов неравные размеры --- проблема при нарушении условий применимости только, если значения доверительной вероятности _p_ близки к выбранному критическому уровню значимости $\alpha$.

---

## Суммы квадратов в многофакторном дисперсионном анализе со взаимодействием

### Если данные сбалансированы, то ...

- взаимодействие и эффекты факторов независимы (в любой параметризации),
- все суммы квадратов и соответствующие тесты можно посчитать в одном анализе,
- результат не зависит от порядка включения факторов в модель.

### Если данные несбалансированы, то ...

- суммы квадратов для факторов не равны общей сумме квадратов,
- для вычислений используется регрессионный подход (несколько сравнений вложенных моделей),
- результат анализа может зависеть от порядка включения факторов в модель. 

---

## Порядок тестирования значимости предикторов в дисперсионном анализе


"Типы сумм квадратов" | I тип | II тип | III тип
---- | ---- | ---- | ---- 
Название | Последовательный | Без учета взаимодействий высоких порядков | Иерархический

---

## Порядок тестирования значимости предикторов <br/> в дисперсионном анализе

.small[

"Типы сумм квадратов" | I тип | II тип | III тип
---- | ---- | ---- | ---- 
Название | Последовательный | Без учета взаимодействий высоких порядков | Иерархический
Порядок расчета SS | SS(A) <br/> SS(B&#124;A)  <br/> SS(AB&#124;B, A) | SS(A&#124;B) <br/> SS(B&#124;A) <br/> SS(AB&#124;B, A) | SS(A&#124;B, AB) <br/> SS(B&#124;A, AB) <br/> SS(AB&#124;B, A)
Величина эффекта зависит от выборки в группе | Да | Да | Нет
Результат зависит от порядка включения факторов в модель | Да | Нет | Нет
Параметризация | Любая | Любая | Только параметризация эффектов
Команда R | aov(), anova() | Anova() (пакет car) |  Anova() (пакет car)

__Осторожно!__ Тестируя предикторы в разном порядке, вы тестируете разные гипотезы!

]

---

## Если несбалансированные данные, выберите подходящий порядок тестирования гипотез

<!-- - SSe и SSab всегда рассчитываются одинаково, вне зависимости от порядка тестирования гипотез и от сбалансированности данных -->
<!-- - SSa, SSb --- есть три способа расчета (суммы квадратов I, II и III типа, терминология пришла из SAS) в зависимости от порядка тестирования значимости факторов -->


### Если данные сбалансированы, то ...

- При использовании любого типа сумм квадратов результаты расчетов будут одинаковы.

### Если данные несбалансированы, то ...

- Результаты зависят от выбранного типа сумм квадратов (т.к. он определяет, какие гипотезы при этом тестируются).

<br/>

Для несбалансированных данных иногда рекомендуют __суммы квадратов III типа__ если есть взаимодействие факторов (Maxwell & Delaney 1990, Milliken, Johnson 1984, Searle 1993, Yandell 1997, Glantz, Slinker 2000). Но при этом __нарушается принцип маргинальности__, поэтому некоторые статистики не любят тех, кто так делает...

---

class: middle, center, inverse

# Многофакторный дисперсионный анализ в R

---

## Дисперсионный анализ со II типом сумм квадратов

При таком способе, сначала тестируется взаимодействие, затем отдельные факторы в модели без взаимодействия.

```{r}
mod_treat_pengs <- lm(mass ~ sp * sex, data = pengs) 
library(car)
Anova(mod_treat_pengs, type = "II")
```

---

## Дисперсионный анализ c III типом сумм квадратов



Опишем процедуру на тот случай, если вдруг вам понадобится воспроизвести в R дисперсионный анализ с III типом сумм квадратов.

При этом способе вначале тестируют взаимодействие, когда все другие факторы есть в модели. Затем тестируют факторы, когда все другие факторы и взаимодействие есть в модели.


--

__Внимание: при использовании III типа сумм квадратов, нужно обязательно указывать тип контрастов для факторов__  
(`contrasts=list(фактор_1 = contr.sum, фактор_2=contr.sum)`).

--

```{r tidy.opts=list(width.cutoff=40)}
mod_sum_pengs <- lm(mass ~ sp * sex, data = pengs, 
                    contrasts = list(sp = 'contr.sum', sex = 'contr.sum')) 
Anova(mod_sum_pengs, type = "III")
```

---

## Почему для расчета III типа сумм квадратов обязательно использовать параметризацию эффектов ?

Для расчета III типа сумм квадратов нужно иметь возможность удалить из модели влияние предиктора, и одновременно оставить в ней взаимодействие (т.е. предикторы и взаимодействие были независимы друг от друга).

--

__В параметризации индикаторных переменных предикторы и взаимодействие коллинеарны__, т.е. суммы квадратов III типа будут рассчитаны неправильно.

```{r}
vif(mod_treat_pengs)
```

--

__В параметризации эффектов переменных предикторы и взаимодействие независимы__, значит получатся верные суммы квадратов III типа.

```{r}
vif(mod_sum_pengs)
```

---

class: middle, center, inverse

# Пост хок тест для взаимодействия факторов

---

## Пост хок тесты в многофакторном дисперсионном анализе

- Поскольку взаимодействие достоверно, факторы отдельно можно не тестировать. Проведем пост хок тест по взаимодействию, чтобы выяснить, какие именно группы различаются

- Если бы взаимодействие было недостоверно, мы бы провели пост хок тест по тем факторам, влияние которых было бы достоверно. Как? См. предыдущую презентацию.

---

## Пост хок тест для взаимодействия факторов

Пост хок тест для взаимодействия факторов делается легче всего "обходным путём":

1. Создаем переменную-взаимодействие; 
2. Подбираем модель без свободного члена;
3. Делаем пост хок тест для этой модели.

---

## Задание 1

Дополните этот код, чтобы посчитать пост хок тест Тьюки по взаимодействию факторов


```{r eval=FALSE, purl=TRUE}
# Создаем переменную-взаимодействие
pengs$sp_sex <- interaction(pengs$sex, pengs$sp)
# Подбираем линейную модель без свободного члена
fit_inter <- lm()
# Делаем пост хок тест для этой модели
library()
dat_tukey <- glht(, linfct = mcp( = ))
summary(dat_tukey)
```

---

## Решение

```{r phoc, eval=FALSE, purl=FALSE}
# Создаем переменную-взаимодействие
pengs$sex_sp <- interaction(pengs$sex, pengs$sp)
# Подбираем линейную модель без свободного члена
fit_inter <- lm(mass ~ sex_sp - 1, data = pengs)
# Делаем пост хок тест для этой модели
library(multcomp)
dat_tukey <- glht(fit_inter, linfct = mcp(sex_sp = 'Tukey'))
summary(dat_tukey)
```

---

## Результаты пост хок теста в виде таблицы почти нечитабельны

```{r phoc, echo=FALSE, purl=FALSE}
```

---

## Данные для графика при помощи `predict()`

У нас два дискретных фактора, поэтому вначале используем `expand.grid()`

```{r}
MyData_pengs <- expand.grid(sex = levels(pengs$sex),
                            sp = levels(pengs$sp))
MyData_pengs <- data.frame(
  MyData_pengs,
  predict(mod_treat_pengs, newdata = MyData_pengs, interval = 'confidence')
)

MyData_pengs
```

---

## Задание 2

Создайте MyData вручную для модели в обычной параметризации:

- предсказанные значения 
- стандартные ошибки
- верхнюю и нижнюю границы доверительных интервалов

```{r eval=FALSE}
MyData_pengs <- expand.grid(sex = levels(pengs$sex),
                            sp = levels(pengs$sp))
X_pengs <- model.matrix(~ , data = )
betas_pengs <- coef()
MyData_pengs$fit <- 
MyData_pengs$se <- (( %*% vcov() %*% t()))
MyData_pengs$lwr <- MyData_pengs$ - 2 * MyData_pengs$
MyData_pengs$upr <- MyData_pengs$ + 2 * MyData_pengs$
MyData_pengs
```


```{r task-mydata, purl=FALSE, echo=FALSE}
MyData_pengs <- expand.grid(sex = levels(pengs$sex),
                            sp = levels(pengs$sp))
X_pengs <- model.matrix(~ sp * sex, data = MyData_pengs)
betas_pengs <- coef(mod_treat_pengs)
MyData_pengs$fit <- X_pengs %*% betas_pengs
MyData_pengs$se <- sqrt(diag(X_pengs %*% vcov(mod_treat_pengs) %*% t(X_pengs)))
MyData_pengs$lwr <- MyData_pengs$fit - 2 * MyData_pengs$se
MyData_pengs$upr <- MyData_pengs$fit + 2 * MyData_pengs$se
MyData_pengs
```

---

## Решение:

```{r task-mydata, purl=FALSE, echo=TRUE}
```

---

## Задание 3

Постройте график результатов, на котором будут изображены предсказанные средние значения видового богатства в зависимости от тритмента и времени экспозиции.


```{r tidy.opts=list(width.cutoff=60), eval=FALSE, purl=TRUE}
pos <- position_dodge(width = 0.2)
gg_linep <- ggplot(data = , aes()) + 
  geom_  (position = pos) +
  geom_  (aes(group = ), position = pos) +
  geom_  (position = pos, width = 0.1) 
gg_linep
```

```{r gg-lineplot, tidy.opts=list(width.cutoff=60), eval=TRUE, purl=FALSE, echo=FALSE}
pos <- position_dodge(width = 0.2)
gg_linep <- ggplot(data = MyData_pengs, aes(x = sp, y = fit, 
                                      ymin = lwr,  ymax = upr, colour = sex)) + 
  geom_point(position = pos) +
  geom_line(aes(group = sex), position = pos) +
  geom_errorbar(position = pos, width = 0.1) 
gg_linep
```

---

## График результатов: Линии с точками

```{r gg-lineplot, tidy.opts=list(width.cutoff=60), eval=TRUE, purl=FALSE, echo=TRUE}
```

---

## Приводим график в приличный вид

```{r tidy.opts=list(width.cutoff=60)}
gg_final <- gg_linep + labs(x = 'Вид', y = 'Масса тела, г') + 
  scale_colour_manual(name = '', labels = c('Самки', 'Самцы'),
                      values = c('#FF0091', '#0077FF'))
gg_final
```

---

## Take home messages

- Многофакторный дисперсионный анализ позволяет оценить взаимодействие факторов. Если оно значимо, то лучше воздержаться от интерпретации их индивидуальных эффектов

--

- Если численности групп равны, получаются одинаковые результаты вне зависимости от порядка тестирования значимости факторов

--

- В случае, если численности групп неравны (несбалансированные данные), есть несколько способов тестирования значимости факторов (I, II, III типы сумм квадратов)

---

## Дополнительные ресурсы

- Quinn, Keough, 2002, pp. 221-250
- Logan, 2010, pp. 313-359
- Sokal, Rohlf, 1995, pp. 321-362
- Zar, 2010, pp. 246-266
